(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["ribbon"],{

/***/ "./bundles/ribbon.js":
/*!***************************!*\
  !*** ./bundles/ribbon.js ***!
  \***************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_ribbon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/ribbon.js */ "./modules/ribbon.js");
/* harmony import */ var _modules_ribbon_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_ribbon_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./modules/ribbon.js":
/*!***************************!*\
  !*** ./modules/ribbon.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
window.sf = window.sf || {};
window.sf.ribbon = function (exports) {
  'use strict';

  /**
   * Defines the layout types of ribbon
   */
  (function (RibbonLayout) {
    /**
     * Displays the ribbon tab content in classic layout.
     */
    RibbonLayout["Classic"] = "Classic";
    /**
     * Displays the ribbon tab content in simplified layout.
     */
    RibbonLayout["Simplified"] = "Simplified";
  })(exports.RibbonLayout || (exports.RibbonLayout = {}));
  /**
   * Defines the alignment of the columns in the ribbon group.
   */

  (function (ItemOrientation) {
    /**
     * Displays the collections in rows and items in columns.
     */
    ItemOrientation["Row"] = "Row";
    /**
     * Displays the collections in columns and items in rows.
     */
    ItemOrientation["Column"] = "Column";
  })(exports.ItemOrientation || (exports.ItemOrientation = {}));
  /**
   * Defines the current size of the ribbon item in normal mode.
   */

  (function (RibbonItemSize) {
    /**
     * The item appears as large icon with text at the bottom.
     */
    RibbonItemSize["Large"] = "Large";
    /**
     * The item appears with small icon and text.
     */
    RibbonItemSize["Medium"] = "Medium";
    /**
     * The item appears only as small icon.
     */
    RibbonItemSize["Small"] = "Small";
  })(exports.RibbonItemSize || (exports.RibbonItemSize = {}));
  /**
   * Defines how to show an item in ribbon simplified layout.
   */

  (function (SimplifiedModePosition) {
    /**
     * The item appears in group.
     */
    SimplifiedModePosition["Group"] = "Group";
    /**
     * The item appears in overflow popup.
     */
    SimplifiedModePosition["Popup"] = "Popup";
    /**
     * The item appears in both group and overflow popup based on overflow state.
     */
    SimplifiedModePosition["Auto"] = "Auto";
    /**
     * The item is hidden in simplified mode.
     */
    SimplifiedModePosition["None"] = "None";
  })(exports.SimplifiedModePosition || (exports.SimplifiedModePosition = {}));
  /**
   * Defines the allowed sizes of the ribbon item in normal mode.
   */

  (function (RibbonAllowedSize) {
    /**
     * The item can resize to All 3 Sizes.
     */
    RibbonAllowedSize["All"] = "All";
    /**
     * The item can resize to Medium and Large Size.
     */
    RibbonAllowedSize["LargeMedium"] = "LargeMedium";
    /**
     * The item can resize to Medium and small Size.
     */
    RibbonAllowedSize["MediumSmall"] = "MediumSmall";
    /**
     * The item cannot be resized and is always in large size.
     */
    RibbonAllowedSize["Large"] = "Large";
    /**
     * The item cannot be resized and is always in large size.
     */
    RibbonAllowedSize["Medium"] = "Medium";
    /**
     * The item cannot be resized and is always in large size.
     */
    RibbonAllowedSize["Small"] = "Small";
  })(exports.RibbonAllowedSize || (exports.RibbonAllowedSize = {}));
  /**
   * Defines the type of the ribbon item.
   */

  (function (RibbonItemType) {
    /**
     * Renders button as ribbon item. .
     */
    RibbonItemType["Button"] = "Button";
    /**
     * Renders checkbox as ribbon item.
     */
    RibbonItemType["CheckBox"] = "CheckBox";
    /**
     * Renders color picker as ribbon item.
     */
    RibbonItemType["ColorPicker"] = "ColorPicker";
    /**
     * Renders combobox as ribbon item
     */
    RibbonItemType["ComboBox"] = "ComboBox";
    /**
     * Renders dropdownbutton or splitbutton based on dropdownsettings as ribbon item.
     */
    RibbonItemType["DropDown"] = "DropDown";
    /**
     * Renders the template property content as ribbon item.
     */
    RibbonItemType["Template"] = "Template";
  })(exports.RibbonItemType || (exports.RibbonItemType = {}));
  var __extends$5 = undefined && undefined.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };
      return _extendStatics(d, b);
    };
    return function (d, b) {
      _extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __decorate$5 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  /**
   * Defines the items of Ribbon.
   */
  var RibbonButtonSettings = /** @class */function (_super) {
    __extends$5(RibbonButtonSettings, _super);
    function RibbonButtonSettings() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {Object} prop - Gets the property of button.
     * @param {boolean} muteOnChange - Gets the boolean value of muteOnChange.
     * @returns {void}
     * @private
     */
    RibbonButtonSettings.prototype.setProperties = function (prop, muteOnChange) {
      _super.prototype.setProperties.call(this, prop, muteOnChange);
    };
    __decorate$5([sf.base.Property('')], RibbonButtonSettings.prototype, "content", void 0);
    __decorate$5([sf.base.Property('')], RibbonButtonSettings.prototype, "cssClass", void 0);
    __decorate$5([sf.base.Property('')], RibbonButtonSettings.prototype, "iconCss", void 0);
    __decorate$5([sf.base.Property(false)], RibbonButtonSettings.prototype, "isToggle", void 0);
    __decorate$5([sf.base.Property(false)], RibbonButtonSettings.prototype, "isPrimary", void 0);
    __decorate$5([sf.base.Event()], RibbonButtonSettings.prototype, "created", void 0);
    __decorate$5([sf.base.Event()], RibbonButtonSettings.prototype, "clicked", void 0);
    return RibbonButtonSettings;
  }(sf.base.ChildProperty);
  var __extends$6 = undefined && undefined.__extends || function () {
    var _extendStatics2 = function extendStatics(d, b) {
      _extendStatics2 = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };
      return _extendStatics2(d, b);
    };
    return function (d, b) {
      _extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __decorate$6 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  /**
   * Defines the items of Ribbon.
   */
  var RibbonCheckBoxSettings = /** @class */function (_super) {
    __extends$6(RibbonCheckBoxSettings, _super);
    function RibbonCheckBoxSettings() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {Object} prop - Gets the property of checkbox.
     * @param {boolean} muteOnChange - Gets the boolean value of muteOnChange.
     * @returns {void}
     * @private
     */
    RibbonCheckBoxSettings.prototype.setProperties = function (prop, muteOnChange) {
      _super.prototype.setProperties.call(this, prop, muteOnChange);
    };
    __decorate$6([sf.base.Property(false)], RibbonCheckBoxSettings.prototype, "checked", void 0);
    __decorate$6([sf.base.Property('')], RibbonCheckBoxSettings.prototype, "cssClass", void 0);
    __decorate$6([sf.base.Property('')], RibbonCheckBoxSettings.prototype, "label", void 0);
    __decorate$6([sf.base.Property('After')], RibbonCheckBoxSettings.prototype, "labelPosition", void 0);
    __decorate$6([sf.base.Event()], RibbonCheckBoxSettings.prototype, "created", void 0);
    __decorate$6([sf.base.Event()], RibbonCheckBoxSettings.prototype, "change", void 0);
    return RibbonCheckBoxSettings;
  }(sf.base.ChildProperty);
  var __extends$7 = undefined && undefined.__extends || function () {
    var _extendStatics3 = function extendStatics(d, b) {
      _extendStatics3 = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };
      return _extendStatics3(d, b);
    };
    return function (d, b) {
      _extendStatics3(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __decorate$7 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  /**
   * Defines the items of Ribbon.
   */
  var RibbonColorPickerSettings = /** @class */function (_super) {
    __extends$7(RibbonColorPickerSettings, _super);
    function RibbonColorPickerSettings() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {Object} prop - Gets the property of colorpicker.
     * @param {boolean} muteOnChange - Gets the boolean value of muteOnChange.
     * @returns {void}
     * @private
     */
    RibbonColorPickerSettings.prototype.setProperties = function (prop, muteOnChange) {
      _super.prototype.setProperties.call(this, prop, muteOnChange);
    };
    __decorate$7([sf.base.Property(10)], RibbonColorPickerSettings.prototype, "columns", void 0);
    __decorate$7([sf.base.Property('')], RibbonColorPickerSettings.prototype, "cssClass", void 0);
    __decorate$7([sf.base.Property(true)], RibbonColorPickerSettings.prototype, "enableOpacity", void 0);
    __decorate$7([sf.base.Property('Picker')], RibbonColorPickerSettings.prototype, "mode", void 0);
    __decorate$7([sf.base.Property(true)], RibbonColorPickerSettings.prototype, "modeSwitcher", void 0);
    __decorate$7([sf.base.Property(false)], RibbonColorPickerSettings.prototype, "noColor", void 0);
    __decorate$7([sf.base.Property(null)], RibbonColorPickerSettings.prototype, "presetColors", void 0);
    __decorate$7([sf.base.Property(true)], RibbonColorPickerSettings.prototype, "showButtons", void 0);
    __decorate$7([sf.base.Property('#008000ff')], RibbonColorPickerSettings.prototype, "value", void 0);
    __decorate$7([sf.base.Event()], RibbonColorPickerSettings.prototype, "beforeClose", void 0);
    __decorate$7([sf.base.Event()], RibbonColorPickerSettings.prototype, "beforeOpen", void 0);
    __decorate$7([sf.base.Event()], RibbonColorPickerSettings.prototype, "beforeTileRender", void 0);
    __decorate$7([sf.base.Event()], RibbonColorPickerSettings.prototype, "created", void 0);
    __decorate$7([sf.base.Event()], RibbonColorPickerSettings.prototype, "change", void 0);
    __decorate$7([sf.base.Event()], RibbonColorPickerSettings.prototype, "open", void 0);
    __decorate$7([sf.base.Event()], RibbonColorPickerSettings.prototype, "select", void 0);
    return RibbonColorPickerSettings;
  }(sf.base.ChildProperty);
  var __extends$8 = undefined && undefined.__extends || function () {
    var _extendStatics4 = function extendStatics(d, b) {
      _extendStatics4 = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };
      return _extendStatics4(d, b);
    };
    return function (d, b) {
      _extendStatics4(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __decorate$8 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  /**
   * Defines the items of Ribbon.
   */
  var RibbonComboBoxSettings = /** @class */function (_super) {
    __extends$8(RibbonComboBoxSettings, _super);
    function RibbonComboBoxSettings() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {Object} prop - Gets the property of combobox.
     * @param {boolean} muteOnChange - Gets the boolean value of muteOnChange.
     * @returns {void}
     * @private
     */
    RibbonComboBoxSettings.prototype.setProperties = function (prop, muteOnChange) {
      _super.prototype.setProperties.call(this, prop, muteOnChange);
    };
    __decorate$8([sf.base.Property(false)], RibbonComboBoxSettings.prototype, "allowFiltering", void 0);
    __decorate$8([sf.base.Property(true)], RibbonComboBoxSettings.prototype, "autofill", void 0);
    __decorate$8([sf.base.Property('')], RibbonComboBoxSettings.prototype, "cssClass", void 0);
    __decorate$8([sf.base.Property([])], RibbonComboBoxSettings.prototype, "dataSource", void 0);
    __decorate$8([sf.base.Complex({
      text: null,
      value: null,
      iconCss: null,
      groupBy: null
    }, sf.dropdowns.FieldSettings)], RibbonComboBoxSettings.prototype, "fields", void 0);
    __decorate$8([sf.base.Property('Contains')], RibbonComboBoxSettings.prototype, "filterType", void 0);
    __decorate$8([sf.base.Property(null)], RibbonComboBoxSettings.prototype, "footerTemplate", void 0);
    __decorate$8([sf.base.Property(null)], RibbonComboBoxSettings.prototype, "groupTemplate", void 0);
    __decorate$8([sf.base.Property(null)], RibbonComboBoxSettings.prototype, "headerTemplate", void 0);
    __decorate$8([sf.base.Property(null)], RibbonComboBoxSettings.prototype, "index", void 0);
    __decorate$8([sf.base.Property(null)], RibbonComboBoxSettings.prototype, "itemTemplate", void 0);
    __decorate$8([sf.base.Property('No records found')], RibbonComboBoxSettings.prototype, "noRecordsTemplate", void 0);
    __decorate$8([sf.base.Property(null)], RibbonComboBoxSettings.prototype, "placeholder", void 0);
    __decorate$8([sf.base.Property('300px')], RibbonComboBoxSettings.prototype, "popupHeight", void 0);
    __decorate$8([sf.base.Property('100%')], RibbonComboBoxSettings.prototype, "popupWidth", void 0);
    __decorate$8([sf.base.Property(true)], RibbonComboBoxSettings.prototype, "showClearButton", void 0);
    __decorate$8([sf.base.Property('None')], RibbonComboBoxSettings.prototype, "sortOrder", void 0);
    __decorate$8([sf.base.Property(null)], RibbonComboBoxSettings.prototype, "text", void 0);
    __decorate$8([sf.base.Property(null)], RibbonComboBoxSettings.prototype, "value", void 0);
    __decorate$8([sf.base.Property('100%')], RibbonComboBoxSettings.prototype, "width", void 0);
    __decorate$8([sf.base.Event()], RibbonComboBoxSettings.prototype, "beforeOpen", void 0);
    __decorate$8([sf.base.Event()], RibbonComboBoxSettings.prototype, "change", void 0);
    __decorate$8([sf.base.Event()], RibbonComboBoxSettings.prototype, "close", void 0);
    __decorate$8([sf.base.Event()], RibbonComboBoxSettings.prototype, "created", void 0);
    __decorate$8([sf.base.Event()], RibbonComboBoxSettings.prototype, "filtering", void 0);
    __decorate$8([sf.base.Event()], RibbonComboBoxSettings.prototype, "open", void 0);
    __decorate$8([sf.base.Event()], RibbonComboBoxSettings.prototype, "select", void 0);
    return RibbonComboBoxSettings;
  }(sf.base.ChildProperty);
  var __extends$9 = undefined && undefined.__extends || function () {
    var _extendStatics5 = function extendStatics(d, b) {
      _extendStatics5 = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };
      return _extendStatics5(d, b);
    };
    return function (d, b) {
      _extendStatics5(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __decorate$9 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  /**
   * Defines the items of Ribbon.
   */
  var RibbonDropDownSettings = /** @class */function (_super) {
    __extends$9(RibbonDropDownSettings, _super);
    function RibbonDropDownSettings() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {Object} prop - Gets the property of DropDown.
     * @param {boolean} muteOnChange - Gets the boolean value of muteOnChange.
     * @returns {void}
     * @private
     */
    RibbonDropDownSettings.prototype.setProperties = function (prop, muteOnChange) {
      _super.prototype.setProperties.call(this, prop, muteOnChange);
    };
    __decorate$9([sf.base.Property('')], RibbonDropDownSettings.prototype, "closeActionEvents", void 0);
    __decorate$9([sf.base.Property('')], RibbonDropDownSettings.prototype, "content", void 0);
    __decorate$9([sf.base.Property('')], RibbonDropDownSettings.prototype, "cssClass", void 0);
    __decorate$9([sf.base.Property('')], RibbonDropDownSettings.prototype, "iconCss", void 0);
    __decorate$9([sf.base.Property(true)], RibbonDropDownSettings.prototype, "isDropDownButton", void 0);
    __decorate$9([sf.base.Collection([], sf.splitbuttons.Item)], RibbonDropDownSettings.prototype, "items", void 0);
    __decorate$9([sf.base.Property('')], RibbonDropDownSettings.prototype, "target", void 0);
    __decorate$9([sf.base.Event()], RibbonDropDownSettings.prototype, "beforeClose", void 0);
    __decorate$9([sf.base.Event()], RibbonDropDownSettings.prototype, "beforeItemRender", void 0);
    __decorate$9([sf.base.Event()], RibbonDropDownSettings.prototype, "beforeOpen", void 0);
    __decorate$9([sf.base.Event()], RibbonDropDownSettings.prototype, "close", void 0);
    __decorate$9([sf.base.Event()], RibbonDropDownSettings.prototype, "created", void 0);
    __decorate$9([sf.base.Event()], RibbonDropDownSettings.prototype, "open", void 0);
    __decorate$9([sf.base.Event()], RibbonDropDownSettings.prototype, "select", void 0);
    return RibbonDropDownSettings;
  }(sf.base.ChildProperty);
  var __extends$10 = undefined && undefined.__extends || function () {
    var _extendStatics6 = function extendStatics(d, b) {
      _extendStatics6 = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };
      return _extendStatics6(d, b);
    };
    return function (d, b) {
      _extendStatics6(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __decorate$10 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  /**
   * Defines the properties for Tooltip of Ribbon.
   */
  var RibbonTooltip = /** @class */function (_super) {
    __extends$10(RibbonTooltip, _super);
    function RibbonTooltip() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$10([sf.base.Property('')], RibbonTooltip.prototype, "cssClass", void 0);
    __decorate$10([sf.base.Property('')], RibbonTooltip.prototype, "id", void 0);
    __decorate$10([sf.base.Property('')], RibbonTooltip.prototype, "title", void 0);
    __decorate$10([sf.base.Property('')], RibbonTooltip.prototype, "content", void 0);
    __decorate$10([sf.base.Property('')], RibbonTooltip.prototype, "iconCss", void 0);
    return RibbonTooltip;
  }(sf.base.ChildProperty);
  var __extends$4 = undefined && undefined.__extends || function () {
    var _extendStatics7 = function extendStatics(d, b) {
      _extendStatics7 = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };
      return _extendStatics7(d, b);
    };
    return function (d, b) {
      _extendStatics7(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __decorate$4 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  /**
   * Defines the items of Ribbon.
   */
  var RibbonItem = /** @class */function (_super) {
    __extends$4(RibbonItem, _super);
    function RibbonItem() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {Object} prop - Gets the property of item.
     * @param {boolean} muteOnChange - Gets the boolean value of muteOnChange.
     * @returns {void}
     * @private
     */
    RibbonItem.prototype.setProperties = function (prop, muteOnChange) {
      _super.prototype.setProperties.call(this, prop, muteOnChange);
    };
    __decorate$4([sf.base.Property(exports.RibbonAllowedSize.All)], RibbonItem.prototype, "allowedSizes", void 0);
    __decorate$4([sf.base.Property('')], RibbonItem.prototype, "id", void 0);
    __decorate$4([sf.base.Property('')], RibbonItem.prototype, "cssClass", void 0);
    __decorate$4([sf.base.Property(false)], RibbonItem.prototype, "disabled", void 0);
    __decorate$4([sf.base.Property('')], RibbonItem.prototype, "ItemTemplate", void 0);
    __decorate$4([sf.base.Property(exports.RibbonItemSize.Medium)], RibbonItem.prototype, "size", void 0);
    __decorate$4([sf.base.Property(exports.RibbonItemType.Button)], RibbonItem.prototype, "type", void 0);
    __decorate$4([sf.base.Property(exports.SimplifiedModePosition.Auto)], RibbonItem.prototype, "simplifiedMode", void 0);
    __decorate$4([sf.base.Complex({}, RibbonButtonSettings)], RibbonItem.prototype, "buttonSettings", void 0);
    __decorate$4([sf.base.Complex({}, RibbonDropDownSettings)], RibbonItem.prototype, "dropDownSettings", void 0);
    __decorate$4([sf.base.Complex({}, RibbonCheckBoxSettings)], RibbonItem.prototype, "checkBoxSettings", void 0);
    __decorate$4([sf.base.Complex({}, RibbonColorPickerSettings)], RibbonItem.prototype, "colorPickerSettings", void 0);
    __decorate$4([sf.base.Complex({}, RibbonComboBoxSettings)], RibbonItem.prototype, "comboBoxSettings", void 0);
    __decorate$4([sf.base.Complex({}, RibbonTooltip)], RibbonItem.prototype, "ribbonTooltipSettings", void 0);
    return RibbonItem;
  }(sf.base.ChildProperty);
  var __extends$3 = undefined && undefined.__extends || function () {
    var _extendStatics8 = function extendStatics(d, b) {
      _extendStatics8 = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };
      return _extendStatics8(d, b);
    };
    return function (d, b) {
      _extendStatics8(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __decorate$3 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  /**
   * Defines the items of Ribbon.
   */
  var RibbonCollection = /** @class */function (_super) {
    __extends$3(RibbonCollection, _super);
    function RibbonCollection() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {Object} prop - Gets the property of collection.
     * @param {boolean} muteOnChange - Gets the boolean value of muteOnChange.
     * @returns {void}
     * @private
     */
    RibbonCollection.prototype.setProperties = function (prop, muteOnChange) {
      _super.prototype.setProperties.call(this, prop, muteOnChange);
    };
    __decorate$3([sf.base.Property('')], RibbonCollection.prototype, "id", void 0);
    __decorate$3([sf.base.Property('')], RibbonCollection.prototype, "cssClass", void 0);
    __decorate$3([sf.base.Collection([], RibbonItem)], RibbonCollection.prototype, "items", void 0);
    return RibbonCollection;
  }(sf.base.ChildProperty);
  var __extends$2 = undefined && undefined.__extends || function () {
    var _extendStatics9 = function extendStatics(d, b) {
      _extendStatics9 = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };
      return _extendStatics9(d, b);
    };
    return function (d, b) {
      _extendStatics9(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __decorate$2 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  /**
   * Defines the items of Ribbon Tab.
   */
  var RibbonGroup = /** @class */function (_super) {
    __extends$2(RibbonGroup, _super);
    function RibbonGroup() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {Object} prop - Gets the property of Group.
     * @param {boolean} muteOnChange - Gets the boolean value of muteOnChange.
     * @returns {void}
     * @private
     */
    RibbonGroup.prototype.setProperties = function (prop, muteOnChange) {
      _super.prototype.setProperties.call(this, prop, muteOnChange);
    };
    __decorate$2([sf.base.Collection([], RibbonCollection)], RibbonGroup.prototype, "collections", void 0);
    __decorate$2([sf.base.Property('')], RibbonGroup.prototype, "cssClass", void 0);
    __decorate$2([sf.base.Property('')], RibbonGroup.prototype, "id", void 0);
    __decorate$2([sf.base.Property(false)], RibbonGroup.prototype, "isCollapsed", void 0);
    __decorate$2([sf.base.Property(true)], RibbonGroup.prototype, "isCollapsible", void 0);
    __decorate$2([sf.base.Property(false)], RibbonGroup.prototype, "enableGroupOverflow", void 0);
    __decorate$2([sf.base.Property('')], RibbonGroup.prototype, "groupIconCss", void 0);
    __decorate$2([sf.base.Property('')], RibbonGroup.prototype, "header", void 0);
    __decorate$2([sf.base.Property(exports.ItemOrientation.Column)], RibbonGroup.prototype, "orientation", void 0);
    __decorate$2([sf.base.Property(0)], RibbonGroup.prototype, "priority", void 0);
    __decorate$2([sf.base.Property(false)], RibbonGroup.prototype, "showLauncherIcon", void 0);
    return RibbonGroup;
  }(sf.base.ChildProperty);
  var __extends$1 = undefined && undefined.__extends || function () {
    var _extendStatics10 = function extendStatics(d, b) {
      _extendStatics10 = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };
      return _extendStatics10(d, b);
    };
    return function (d, b) {
      _extendStatics10(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  /**
   * Defines the items of Ribbon.
   */
  var RibbonTab = /** @class */function (_super) {
    __extends$1(RibbonTab, _super);
    function RibbonTab() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {Object} prop - Gets the property of tab.
     * @param {boolean} muteOnChange - Gets the boolean value of muteOnChange.
     * @returns {void}
     * @private
     */
    RibbonTab.prototype.setProperties = function (prop, muteOnChange) {
      _super.prototype.setProperties.call(this, prop, muteOnChange);
    };
    __decorate$1([sf.base.Property(false)], RibbonTab.prototype, "enableGroupOverflow", void 0);
    __decorate$1([sf.base.Property('')], RibbonTab.prototype, "id", void 0);
    __decorate$1([sf.base.Property('')], RibbonTab.prototype, "cssClass", void 0);
    __decorate$1([sf.base.Collection([], RibbonGroup)], RibbonTab.prototype, "groups", void 0);
    __decorate$1([sf.base.Property('')], RibbonTab.prototype, "header", void 0);
    return RibbonTab;
  }(sf.base.ChildProperty);
  var __extends$11 = undefined && undefined.__extends || function () {
    var _extendStatics11 = function extendStatics(d, b) {
      _extendStatics11 = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };
      return _extendStatics11(d, b);
    };
    return function (d, b) {
      _extendStatics11(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __decorate$11 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  /**
   * Defines the properties for FileMenu of Ribbon.
   */
  var FileMenuSettings = /** @class */function (_super) {
    __extends$11(FileMenuSettings, _super);
    function FileMenuSettings() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {Object} prop - Gets the property of FileMenu.
     * @param {boolean} muteOnChange - Gets the boolean value of muteOnChange.
     * @returns {void}
     * @private
     */
    FileMenuSettings.prototype.setProperties = function (prop, muteOnChange) {
      _super.prototype.setProperties.call(this, prop, muteOnChange);
    };
    __decorate$11([sf.base.Property('File')], FileMenuSettings.prototype, "text", void 0);
    __decorate$11([sf.base.Property(false)], FileMenuSettings.prototype, "visible", void 0);
    __decorate$11([sf.base.Collection([], sf.navigations.MenuItem)], FileMenuSettings.prototype, "menuItems", void 0);
    __decorate$11([sf.base.Property(false)], FileMenuSettings.prototype, "showItemOnClick", void 0);
    __decorate$11([sf.base.Complex({}, sf.navigations.MenuAnimationSettings)], FileMenuSettings.prototype, "animationSettings", void 0);
    __decorate$11([sf.base.Property('')], FileMenuSettings.prototype, "itemTemplate", void 0);
    __decorate$11([sf.base.Property('')], FileMenuSettings.prototype, "popupTemplate", void 0);
    __decorate$11([sf.base.Complex({}, RibbonTooltip)], FileMenuSettings.prototype, "tooltip", void 0);
    __decorate$11([sf.base.Event()], FileMenuSettings.prototype, "beforeClose", void 0);
    __decorate$11([sf.base.Event()], FileMenuSettings.prototype, "beforeOpen", void 0);
    __decorate$11([sf.base.Event()], FileMenuSettings.prototype, "beforeItemRender", void 0);
    __decorate$11([sf.base.Event()], FileMenuSettings.prototype, "close", void 0);
    __decorate$11([sf.base.Event()], FileMenuSettings.prototype, "open", void 0);
    __decorate$11([sf.base.Event()], FileMenuSettings.prototype, "select", void 0);
    return FileMenuSettings;
  }(sf.base.ChildProperty);

  // export * from './file-menu';

  /**
   * Specifies the File Manager internal ID's
   */
  /** @hidden */
  var ITEM_VERTICAL_CENTER = 'e-ribbon-vertical-center';
  /** @hidden */
  var EXPAND_COLLAPSE_ICON = 'e-icons e-drop-icon';
  /** @hidden */
  var OVERFLOW_ICON = 'e-icons e-more-horizontal-1';
  /** @hidden */
  var VERTICAL_DDB = 'e-vertical';
  /** @hidden */
  var DISABLED_CSS = 'e-disabled';
  /** @hidden */
  var RTL_CSS = 'e-rtl';
  /** @hidden */
  var SPACE = ' ';
  /** @hidden */
  var HORIZONTAL_SCROLLBAR = 'e-hscroll-bar';
  /** @hidden */
  var RIBBON_TAB = 'e-ribbon-tab';
  /** @hidden */
  var RIBBON_TAB_ACTIVE = 'e-ribbon-active';
  /** @hidden */
  var RIBBON_TAB_ITEM = 'e-ribbon-tab-item';
  /** @hidden */
  var RIBBON_COLLAPSE_BUTTON = 'e-ribbon-collapse-btn';
  /** @hidden */
  var RIBBON_EXPAND_BUTTON = 'e-ribbon-expand-btn';
  /** @hidden */
  var RIBBON_COLLAPSIBLE = 'e-ribbon-collapsible';
  /** @hidden */
  var RIBBON_OVERALL_OF_BUTTON = 'e-ribbon-overall-of-btn';
  /** @hidden */
  var RIBBON_GROUP_OF_BUTTON = 'e-ribbon-group-of-btn';
  /** @hidden */
  var RIBBON_OVERFLOW_TARGET = 'e-ribbon-overflow-target';
  /** @hidden */
  var RIBBON_OVERFLOW = 'e-ribbon-overflow';
  /** @hidden */
  var TAB_CONTENT = 'e-content';
  /** @hidden */
  var RIBBON_MINIMIZE = 'e-ribbon-minimize';
  /** @hidden */
  var RIBBON_GROUP = 'e-ribbon-group';
  /** @hidden */
  var RIBBON_GROUP_CONTAINER = 'e-ribbon-group-container';
  /** @hidden */
  var RIBBON_OF_TAB_CONTAINER = 'e-ribbon-of-tab';
  /** @hidden */
  var RIBBON_OF_GROUP_CONTAINER = 'e-ribbon-of-group-container';
  /** @hidden */
  var RIBBON_GROUP_CONTENT = 'e-ribbon-group-content';
  /** @hidden */
  var RIBBON_GROUP_HEADER = 'e-ribbon-group-header';
  /** @hidden */
  var RIBBON_OVERFLOW_HEADER = 'e-ribbon-overflow-header';
  /** @hidden */
  var RIBBON_GROUP_OVERFLOW = 'e-ribbon-group-overflow';
  /** @hidden */
  var RIBBON_GROUP_OVERFLOW_DDB = 'e-ribbon-group-overflow-ddb';
  /** @hidden */
  var RIBBON_LAUNCHER = 'e-ribbon-launcher';
  /** @hidden */
  var RIBBON_LAUNCHER_ICON_ELE = 'e-ribbon-launcher-icon';
  /** @hidden */
  var RIBBON_LAUNCHER_ICON = 'e-icons e-launcher';
  /** @hidden */
  var RIBBON_COLLECTION = 'e-ribbon-collection';
  /** @hidden */
  var RIBBON_ITEM = 'e-ribbon-item';
  /** @hidden */
  var RIBBON_ROW = 'e-ribbon-row';
  /** @hidden */
  var RIBBON_COLUMN = 'e-ribbon-column';
  /** @hidden */
  var RIBBON_LARGE_ITEM = 'e-ribbon-large-item';
  /** @hidden */
  var RIBBON_MEDIUM_ITEM = 'e-ribbon-medium-item';
  /** @hidden */
  var RIBBON_SMALL_ITEM = 'e-ribbon-small-item';
  /** @hidden */
  var RIBBON_CONTENT_HEIGHT = 'e-ribbon-content-height';
  /** @hidden */
  var RIBBON_SIZE_CHECK = 'e-ribbon-size-check';
  /** @hidden */
  var DROPDOWNBUTTON = 'e-dropdown-btn';
  /** @hidden */
  var DROPDOWNBUTTON_HIDE = 'e-caret-hide';
  /** @hidden */
  var RIBBON_RIGHT_TEMPLATE = 'e-ribbon-right-template';
  /** @hidden */
  var RIBBON_TOOLTIP = 'e-ribbon-tooltip';
  /** @hidden */
  var RIBBON_TOOLTIP_TARGET = 'e-ribbon-tooltip-target';
  /** @hidden */
  var RIBBON_TOOLTIP_TITLE = 'e-ribbon-tooltip-title';
  /** @hidden */
  var RIBBON_TOOLTIP_CONTENT = 'e-ribbon-tooltip-content';
  /** @hidden */
  var RIBBON_TOOLTIP_ICON = 'e-ribbon-tooltip-icon';
  /** @hidden */
  var RIBBON_TOOLTIP_CONTAINER = 'e-ribbon-tooltip-container';
  /** @hidden */
  var RIBBON_TEXT_CONTAINER = 'e-ribbon-text-container';
  /** @hidden */
  var RIBBON_SIMPLIFIED_MODE = 'e-ribbon-simplified-mode';
  /** @hidden */
  var TAB_ID = '_tab';
  /** @hidden */
  var GROUP_ID = '_group';
  /** @hidden */
  var COLLECTION_ID = '_collection';
  /** @hidden */
  var ITEM_ID = '_item';
  /** @hidden */
  var COLLAPSE_BUTTON_ID = '_collapsebutton';
  /** @hidden */
  var OVRLOF_BUTTON_ID = '_sim_ovrl_overflow';
  /** @hidden */
  var GROUPOF_BUTTON_ID = '_sim_grp_overflow';
  /** @hidden */
  var HEADER_ID = '_header';
  /** @hidden */
  var LAUNCHER_ID = '_launcher';
  /** @hidden */
  var CONTENT_ID = '_content';
  /** @hidden */
  var CONTAINER_ID = '_container';
  /** @hidden */
  var OVERFLOW_ID = '_overflow';
  /** @hidden */
  var DROPDOWN_ID = '_dropdown';
  /** @hidden */
  var RIBBON_FILE_MENU_ID = '_filemenu';
  /** @hidden */
  var RIBBON_RIGHT_PANE_TEMPLATE_ID = '_rightpanetemplate';
  /** @hidden */
  var RIBBON_FILE_MENU_WIDTH = '--fileMenuWidth';
  /** @hidden */
  var RIBBON_RIGHT_PANE_TEMPLATE_WIDTH = '--rightTemplateWidth';

  /**
   * Defines the items of Ribbon.
   */
  var RibbonButton = /** @class */function () {
    function RibbonButton(parent) {
      this.parent = parent;
    }
    RibbonButton.prototype.getModuleName = function () {
      return 'ribbonButton';
    };
    RibbonButton.prototype.destroy = function () {
      this.parent = null;
    };
    /**
     * Creates button.
     *
     * @param {RibbonItemModel} item - Gets the ribbon item model.
     * @param {HTMLElement} itemEle - Gets the ribbon item element.
     * @returns {void}
     * @hidden
     */
    RibbonButton.prototype.createButton = function (item, itemEle) {
      var _this = this;
      var buttonEle = this.parent.createElement('button', {
        id: item.id
      });
      itemEle.appendChild(buttonEle);
      var btnSettings = item.buttonSettings;
      new sf.buttons.Button({
        locale: this.parent.locale,
        enableRtl: this.parent.enableRtl,
        enablePersistence: this.parent.enablePersistence,
        iconPosition: item.size === 'Large' ? 'Top' : 'Left',
        iconCss: btnSettings.iconCss,
        disabled: item.disabled,
        cssClass: btnSettings.cssClass ? (ITEM_VERTICAL_CENTER + SPACE + btnSettings.cssClass).trim() : ITEM_VERTICAL_CENTER,
        content: item.size === 'Small' ? '' : btnSettings.content,
        isPrimary: btnSettings.isPrimary,
        isToggle: btnSettings.isToggle,
        created: btnSettings.created
      }, buttonEle);
      var buttonClicked = function buttonClicked(e) {
        if (btnSettings.clicked) {
          btnSettings.clicked.call(_this, e);
        }
      };
      sf.base.EventHandler.add(buttonEle, 'click', buttonClicked.bind(this), this);
    };
    /**
     * Triggers the click action on the button.
     *
     * @param {string} controlId - Gets the control ID.
     * @returns {void}
     */
    RibbonButton.prototype.click = function (controlId) {
      var buttonEle = this.parent.element.querySelector('#' + controlId);
      if (!buttonEle) {
        return;
      }
      var buttonObj = sf.base.getComponent(buttonEle, sf.buttons.Button);
      buttonObj.click();
    };
    /**
     * Updates the button properties.
     *
     * @param {RibbonButtonSettingsModel} prop - Gets the button property.
     * @param {string} id - Gets the ID of button item.
     * @returns {void}
     */
    RibbonButton.prototype.updateButton = function (prop, id) {
      var itemProp = getItem(this.parent.tabs, id);
      if (!itemProp) {
        return;
      }
      this.updateButtonProp(itemProp, prop, id);
    };
    /**
     * Updates the button properties.
     *
     * @param {itemProps} itemProp - Gets the property of item.
     * @param {RibbonButtonSettingsModel} prop - Gets the button property.
     * @param {string} id - Gets the ID of button item.
     * @returns {void}
     * @hidden
     */
    RibbonButton.prototype.updateButtonProp = function (itemProp, prop, id) {
      sf.base.merge(itemProp.item.buttonSettings, prop);
      var buttonEle = getItemElement(this.parent, itemProp, id);
      if (!buttonEle) {
        return;
      }
      var buttonObj = sf.base.getComponent(buttonEle, sf.buttons.Button);
      if (prop.cssClass) {
        prop.cssClass = (ITEM_VERTICAL_CENTER + SPACE + prop.cssClass).trim();
      }
      if (prop.content) {
        prop.content = itemProp.item.size === 'Small' ? '' : prop.content;
      }
      buttonObj.setProperties(prop);
    };
    /**
     * Updates the button size.
     *
     * @param {HTMLElement} element - Gets the button element.
     * @param {RibbonItemModel} item - Gets the ribbon item.
     * @returns {void}
     * @hidden
     */
    RibbonButton.prototype.updateButtonSize = function (element, item) {
      var buttonObj = sf.base.getComponent(element, sf.buttons.Button);
      buttonObj.setProperties({
        iconPosition: item.size === 'Large' ? 'Top' : 'Left',
        content: item.size === 'Small' ? '' : item.buttonSettings.content
      });
    };
    return RibbonButton;
  }();

  /**
   * Defines the items of Ribbon.
   */
  var RibbonCheckBox = /** @class */function () {
    function RibbonCheckBox(parent) {
      this.parent = parent;
    }
    RibbonCheckBox.prototype.getModuleName = function () {
      return 'ribbonCheckBox';
    };
    RibbonCheckBox.prototype.destroy = function () {
      this.parent = null;
    };
    /**
     * Creates the check box.
     *
     * @param {RibbonItemModel} item - Gets the ribbon item model.
     * @param {HTMLElement} itemEle - Gets the ribbon item element.
     * @returns {void}
     * @hidden
     */
    RibbonCheckBox.prototype.createCheckBox = function (item, itemEle) {
      var inputEle = this.parent.createElement('input', {
        id: item.id
      });
      itemEle.appendChild(inputEle);
      var checkBoxSettings = item.checkBoxSettings;
      new sf.buttons.CheckBox({
        locale: this.parent.locale,
        enableRtl: this.parent.enableRtl,
        enablePersistence: this.parent.enablePersistence,
        checked: checkBoxSettings.checked,
        cssClass: checkBoxSettings.cssClass,
        label: checkBoxSettings.label,
        labelPosition: checkBoxSettings.labelPosition,
        disabled: item.disabled,
        created: checkBoxSettings.created,
        change: checkBoxSettings.change
      }, inputEle);
    };
    /**
     * Triggers the click action on the Checkbox.
     *
     * @param {string} controlId - Gets the control ID.
     * @returns {void}
     */
    RibbonCheckBox.prototype.click = function (controlId) {
      var inputEle = this.parent.element.querySelector('#' + controlId);
      if (!inputEle) {
        return;
      }
      var checkBoxObj = sf.base.getComponent(inputEle, sf.buttons.CheckBox);
      checkBoxObj.click();
    };
    /**
     * Updates the checkbox.
     *
     * @param {RibbonCheckBoxSettingsModel} prop - Gets the checkbox property.
     * @param {string} id - Gets the ID of checkbox.
     * @returns {void}
     */
    RibbonCheckBox.prototype.updateCheckBox = function (prop, id) {
      var itemProp = getItem(this.parent.tabs, id);
      if (!itemProp) {
        return;
      }
      this.updateCheckBoxProp(itemProp, prop, id);
    };
    /**
     * Updates the checkbox properties.
     *
     * @param {itemProps} itemProp - Gets the property of ribbon item.
     * @param {RibbonCheckBoxSettingsModel} prop - Gets the property of checkbox.
     * @param {string} id - Gets the ID of checkbox item.
     * @returns {void}
     * @hidden
     */
    RibbonCheckBox.prototype.updateCheckBoxProp = function (itemProp, prop, id) {
      sf.base.merge(itemProp.item.checkBoxSettings, prop);
      var inputEle = getItemElement(this.parent, itemProp, id);
      if (!inputEle) {
        return;
      }
      var checkBoxObj = sf.base.getComponent(inputEle, sf.buttons.CheckBox);
      checkBoxObj.setProperties(prop);
    };
    return RibbonCheckBox;
  }();

  /**
   * Defines the items of Ribbon.
   */
  var RibbonColorPicker = /** @class */function () {
    function RibbonColorPicker(parent) {
      this.parent = parent;
    }
    RibbonColorPicker.prototype.getModuleName = function () {
      return 'ribbonColorPicker';
    };
    RibbonColorPicker.prototype.destroy = function () {
      this.parent = null;
    };
    /**
     * Creates the colorpicker.
     *
     * @param {RibbonItemModel} item - Gets the ribbon item model.
     * @param {HTMLElement} itemEle - Gets the ribbon item element.
     * @returns {void}
     * @hidden
     */
    RibbonColorPicker.prototype.createColorPicker = function (item, itemEle) {
      var inputEle = this.parent.createElement('input', {
        id: item.id
      });
      itemEle.appendChild(inputEle);
      var colorPickerSettings = item.colorPickerSettings;
      new sf.inputs.ColorPicker({
        locale: this.parent.locale,
        enableRtl: this.parent.enableRtl,
        enablePersistence: this.parent.enablePersistence,
        columns: colorPickerSettings.columns,
        cssClass: colorPickerSettings.cssClass,
        disabled: item.disabled,
        enableOpacity: colorPickerSettings.enableOpacity,
        mode: colorPickerSettings.mode,
        modeSwitcher: colorPickerSettings.modeSwitcher,
        noColor: colorPickerSettings.noColor,
        presetColors: colorPickerSettings.presetColors,
        showButtons: colorPickerSettings.showButtons,
        value: colorPickerSettings.value,
        beforeClose: colorPickerSettings.beforeClose,
        beforeOpen: colorPickerSettings.beforeOpen,
        beforeTileRender: colorPickerSettings.beforeTileRender,
        created: colorPickerSettings.created,
        change: colorPickerSettings.change,
        open: colorPickerSettings.open,
        select: colorPickerSettings.select
      }, inputEle);
    };
    RibbonColorPicker.prototype.getColorPickerObj = function (controlId) {
      var colorPickerEle = this.parent.element.querySelector('#' + controlId);
      return colorPickerEle ? sf.base.getComponent(colorPickerEle, sf.inputs.ColorPicker) : null;
    };
    /**
     * Gets color value in specified type.
     *
     * @param {string} controlId -Gets the control ID.
     * @param {string} value - Specify the color value.
     * @param {string} type - Specify the type to which the specified color needs to be converted.
     * @returns {string} - Returns string.
     */
    RibbonColorPicker.prototype.getValue = function (controlId, value, type) {
      var colorPickerObj = this.getColorPickerObj(controlId);
      return colorPickerObj ? colorPickerObj.getValue(value, type) : '';
    };
    /**
     * To show/hide ColorPicker popup based on current state of the SplitButton.
     *
     * @param {string} controlId - set the id of the control.
     * @returns {void} - Returns void.
     */
    RibbonColorPicker.prototype.toggle = function (controlId) {
      var colorPickerObj = this.getColorPickerObj(controlId);
      if (!colorPickerObj) {
        return;
      }
      colorPickerObj.toggle();
    };
    /**
     * Updates the colorpicker properties.
     *
     * @param {RibbonColorPickerSettingsModel} prop - Gets the colorpicker property.
     * @param {string} id - Gets the ID of colorpicker.
     * @returns {void}
     */
    RibbonColorPicker.prototype.updateColorPicker = function (prop, id) {
      var itemProp = getItem(this.parent.tabs, id);
      if (!itemProp) {
        return;
      }
      this.updateColorPickerProp(itemProp, prop, id);
    };
    /**
     * Updates the colorpicker properties.
     *
     * @param {itemProps} itemProp - Gets the property of ribbon item.
     * @param {RibbonColorPickerSettingsModel} prop - Gets the property of checkbox.
     * @param {string} id - Gets the ID of colorpicker item.
     * @returns {void} - Returns void.
     * @hidden
     */
    RibbonColorPicker.prototype.updateColorPickerProp = function (itemProp, prop, id) {
      sf.base.merge(itemProp.item.checkBoxSettings, prop);
      var inputEle = getItemElement(this.parent, itemProp, id);
      if (!inputEle) {
        return;
      }
      var colorPickerObj = sf.base.getComponent(inputEle, sf.inputs.ColorPicker);
      colorPickerObj.setProperties(prop);
    };
    return RibbonColorPicker;
  }();

  /**
   * Defines the items of Ribbon.
   */
  var RibbonComboBox = /** @class */function () {
    function RibbonComboBox(parent) {
      this.parent = parent;
    }
    RibbonComboBox.prototype.getModuleName = function () {
      return 'ribbonComboBox';
    };
    RibbonComboBox.prototype.destroy = function () {
      this.parent = null;
    };
    /**
     * Creates the combobox.
     *
     * @param {RibbonItemModel} item - Gets the ribbon item model.
     * @param {HTMLElement} itemEle - Gets the ribbon item element.
     * @returns {void}
     * @hidden
     */
    RibbonComboBox.prototype.createComboBox = function (item, itemEle) {
      var inputEle = this.parent.createElement('input', {
        id: item.id
      });
      itemEle.appendChild(inputEle);
      var comboBoxSettings = item.comboBoxSettings;
      new sf.dropdowns.ComboBox({
        locale: this.parent.locale,
        enableRtl: this.parent.enableRtl,
        enablePersistence: this.parent.enablePersistence,
        allowCustom: false,
        floatLabelType: 'Never',
        ignoreAccent: true,
        ignoreCase: true,
        allowFiltering: comboBoxSettings.allowFiltering,
        autofill: comboBoxSettings.autofill,
        cssClass: comboBoxSettings.cssClass,
        dataSource: comboBoxSettings.dataSource,
        enabled: !item.disabled,
        fields: comboBoxSettings.fields,
        filterType: comboBoxSettings.filterType,
        footerTemplate: comboBoxSettings.footerTemplate,
        groupTemplate: comboBoxSettings.groupTemplate,
        headerTemplate: comboBoxSettings.headerTemplate,
        index: comboBoxSettings.index,
        itemTemplate: comboBoxSettings.itemTemplate,
        noRecordsTemplate: comboBoxSettings.noRecordsTemplate,
        placeholder: comboBoxSettings.placeholder,
        popupHeight: comboBoxSettings.popupHeight,
        popupWidth: comboBoxSettings.popupWidth,
        showClearButton: comboBoxSettings.showClearButton,
        sortOrder: comboBoxSettings.sortOrder,
        text: comboBoxSettings.text,
        value: comboBoxSettings.value,
        width: comboBoxSettings.width ? comboBoxSettings.width : '100px',
        beforeOpen: comboBoxSettings.beforeOpen,
        open: comboBoxSettings.open,
        close: comboBoxSettings.close,
        filtering: comboBoxSettings.filtering,
        change: comboBoxSettings.change,
        select: comboBoxSettings.select
      }, inputEle);
    };
    RibbonComboBox.prototype.getComboBoxObj = function (controlId) {
      var dropDownEle = this.parent.element.querySelector('#' + controlId);
      return dropDownEle ? sf.base.getComponent(dropDownEle, sf.dropdowns.ComboBox) : null;
    };
    /**
     * To filter the data from given data source by using query
     *
     * @param  {string } controlId - set the id of the control in which methods needs to be called.
     * @param  {Object[] } dataSource - Set the data source to filter.
     * @param  {Query} query - Specify the query to filter the data.
     * @param  {FieldSettingsModel} fields - Specify the fields to map the column in the data table.
     * @returns {void}
     */
    RibbonComboBox.prototype.filter = function (controlId, dataSource, query, fields) {
      this.getComboBoxObj(controlId).filter(dataSource, query, fields);
    };
    /**
     * To open/close DropDownButton popup based on current state of the combobox.
     *
     * @param {string} controlId - Gets the id of the control.
     * @returns {void}
     */
    RibbonComboBox.prototype.hidePopup = function (controlId) {
      var comboBoxObj = this.getComboBoxObj(controlId);
      if (!comboBoxObj) {
        return;
      }
      comboBoxObj.hidePopup();
    };
    /**
     * To open/close DropDownButton popup based on current state of the combobox.
     *
     * @param {string} controlId - Gets the id of the control.
     * @returns {void}
     */
    RibbonComboBox.prototype.showPopup = function (controlId) {
      var comboBoxObj = this.getComboBoxObj(controlId);
      if (!comboBoxObj) {
        return;
      }
      comboBoxObj.showPopup();
    };
    /**
     * Updates the combobox properties.
     *
     * @param {RibbonComboBoxSettingsModel} prop - Gets the combobox property.
     * @param {string} id - Gets the ID of combobox.
     * @returns {void}
     */
    RibbonComboBox.prototype.updateComboBox = function (prop, id) {
      var itemProp = getItem(this.parent.tabs, id);
      if (!itemProp) {
        return;
      }
      this.updateComboBoxProp(itemProp, prop, id);
    };
    /**
     * Updates the combobox properties.
     *
     * @param {itemProps} itemProp - Gets the property of ribbon combobox item.
     * @param {RibbonComboBoxSettingsModel} prop - Gets the property of combobox.
     * @param {string} id - Gets the ID of combobox item.
     * @returns {void}
     * @hidden
     */
    RibbonComboBox.prototype.updateComboBoxProp = function (itemProp, prop, id) {
      sf.base.merge(itemProp.item.comboBoxSettings, prop);
      var inputEle = getItemElement(this.parent, itemProp, id);
      if (!inputEle) {
        return;
      }
      var comboBoxObj = sf.base.getComponent(inputEle, sf.dropdowns.ComboBox);
      comboBoxObj.setProperties(prop);
    };
    return RibbonComboBox;
  }();

  /**
   * Defines the items of Ribbon.
   */
  var RibbonDropDown = /** @class */function () {
    function RibbonDropDown(parent) {
      this.parent = parent;
    }
    RibbonDropDown.prototype.getModuleName = function () {
      return 'ribbonDropDown';
    };
    RibbonDropDown.prototype.destroy = function () {
      this.parent = null;
    };
    /**
     * Creates DropDown.
     *
     * @param {RibbonItemModel} item - Gets the ribbon item model.
     * @param {HTMLElement} itemEle - Gets the ribbon item element.
     * @returns {void}
     * @hidden
     */
    RibbonDropDown.prototype.createDropDown = function (item, itemEle) {
      var buttonEle = this.parent.createElement('button', {
        id: item.id
      });
      itemEle.appendChild(buttonEle);
      var dropDownSettings = item.dropDownSettings;
      var options = {
        locale: this.parent.locale,
        enableRtl: this.parent.enableRtl,
        enablePersistence: this.parent.enablePersistence,
        iconPosition: item.size === 'Large' ? 'Top' : 'Left',
        closeActionEvents: dropDownSettings.closeActionEvents,
        content: item.size === 'Small' ? '' : dropDownSettings.content,
        cssClass: dropDownSettings.cssClass ? (ITEM_VERTICAL_CENTER + SPACE + dropDownSettings.cssClass).trim() : ITEM_VERTICAL_CENTER,
        disabled: item.disabled,
        iconCss: dropDownSettings.iconCss,
        items: dropDownSettings.items,
        target: dropDownSettings.target,
        beforeClose: dropDownSettings.beforeClose,
        beforeItemRender: dropDownSettings.beforeItemRender,
        beforeOpen: dropDownSettings.beforeOpen,
        close: dropDownSettings.close,
        created: dropDownSettings.created,
        open: dropDownSettings.open,
        select: dropDownSettings.select
      };
      if (item.size === 'Large') {
        options.cssClass = VERTICAL_DDB + SPACE + options.cssClass;
      }
      if (dropDownSettings.isDropDownButton) {
        new sf.splitbuttons.DropDownButton(options, buttonEle);
      } else {
        new sf.splitbuttons.SplitButton(options, buttonEle);
      }
    };
    /**
     * Creates Overflow DropDown.
     *
     * @param {string} id - Gets the ID of the dropdown item.
     * @param {string} name - Gets the name of the dropdown item.
     * @param {string} iconCss - Gets the icon of the dropdown item.
     * @param {HTMLElement} groupEle - Gets the overflow group element.
     * @param {HTMLElement} overflowEle - Gets the overflow element.
     * @returns {void}
     * @hidden
     */
    RibbonDropDown.prototype.createOverFlowDropDown = function (id, name, iconCss, groupEle, overflowEle) {
      var buttonEle = this.parent.createElement('button', {
        id: id + OVERFLOW_ID + DROPDOWN_ID
      });
      overflowEle.appendChild(buttonEle);
      new sf.splitbuttons.DropDownButton({
        iconCss: iconCss,
        target: groupEle,
        cssClass: VERTICAL_DDB + SPACE + RIBBON_GROUP_OVERFLOW_DDB,
        iconPosition: 'Top',
        content: name
      }, buttonEle);
      var tooltip = new sf.popups.Tooltip({
        cssClass: (RIBBON_TOOLTIP + ' ' + this.parent.cssClass).trim(),
        target: '.' + RIBBON_TOOLTIP_TARGET,
        beforeRender: beforeTooltipRender.bind(this)
      }, groupEle);
      /**
       * @param {TooltipEventArgs} args - Gets the tooltip argument
       * @returns {void}
       */
      function beforeTooltipRender(args) {
        setToolTipContent(args, tooltip, this.parent.tooltipData);
      }
    };
    /**
     * Removes Overflow DropDown.
     *
     * @param {HTMLElement} dropdownElement - Gets the ribbon DropDown element.
     * @returns {void}
     * @hidden
     */
    RibbonDropDown.prototype.removeOverFlowDropDown = function (dropdownElement) {
      var dropdown = sf.base.getComponent(dropdownElement, sf.splitbuttons.DropDownButton);
      var tooltip = sf.base.getComponent(dropdown.target, sf.popups.Tooltip);
      tooltip.destroy();
      dropdownElement.parentElement.parentElement.insertBefore(dropdown.target, dropdownElement.parentElement);
      dropdown.destroy();
      sf.base.remove(dropdownElement);
    };
    /**
     * Gets DropDown item element.
     *
     * @param {HTMLElement} dropdownElement - Gets the ribbon DropDown element.
     * @param {string} id - Gets the ID of ribbon DropDown element.
     * @returns {HTMLElement} - Returns the DropDown item element.
     * @hidden
     */
    RibbonDropDown.prototype.getDDBItemElement = function (dropdownElement, id) {
      var dropdown = sf.base.getComponent(dropdownElement, sf.splitbuttons.DropDownButton);
      var dropDownPopup = dropdown.dropDown.element;
      return dropDownPopup.querySelector('#' + id);
    };
    /**
     * Gets Overflow DropDown Popup.
     *
     * @param {itemProps} itemProp - Gets the property of ribbon item.
     * @param {HTMLElement} contentEle - Gets the content element.
     * @returns {HTMLElement} - Returns the Overflow DropDown Popup.
     * @hidden
     */
    RibbonDropDown.prototype.getOverflowDropDownPopup = function (itemProp, contentEle) {
      var dropdownElement = contentEle.querySelector('#' + this.parent.tabs[itemProp.tabIndex].groups[itemProp.groupIndex].id + OVERFLOW_ID + DROPDOWN_ID);
      var dropdown = sf.base.getComponent(dropdownElement, sf.splitbuttons.DropDownButton);
      return dropdown.dropDown.element;
    };
    RibbonDropDown.prototype.getDropDownObj = function (controlId) {
      var dropDownEle = this.parent.element.querySelector('#' + controlId);
      return sf.base.getComponent(dropDownEle, dropDownEle.classList.contains(DROPDOWNBUTTON) ? sf.splitbuttons.DropDownButton : sf.splitbuttons.SplitButton);
    };
    /**
     * Adds a new item to the menu. By default, new item appends to
     * the list as the last item, but you can insert based on the text parameter.
     *
     * @param {string} controlId - Gets the control ID.
     * @param {ItemModel[]} Items - Gets the DropDown items.
     * @param {string} text - Gets the text of the dropdown item where the new item needs to be inserted.
     * @returns {void}
     */
    RibbonDropDown.prototype.addItems = function (controlId, Items, text) {
      this.getDropDownObj(controlId).addItems(Items, text);
    };
    /**
     * Removes the items from the menu.
     *
     * @param {string} controlId - Gets the control ID.
     * @param {string[]} Items -
     * @param {string} isUniqueId -
     * @returns {void}
     */
    RibbonDropDown.prototype.removeItems = function (controlId, Items, isUniqueId) {
      this.getDropDownObj(controlId).removeItems(Items, isUniqueId);
    };
    /**
     * To open/close DropDownButton popup based on current state of the DropDownButton.
     *
     * @param {string} controlId - Gets the control ID.
     * @returns {void}
     */
    RibbonDropDown.prototype.toggle = function (controlId) {
      this.getDropDownObj(controlId).toggle();
    };
    /**
     * Updates the dropdown.
     *
     * @param {RibbonDropDownSettingsModel} prop - Gets the dropdown property.
     * @param {string} id - Gets the ID of dropdown.
     * @returns {void}
     */
    RibbonDropDown.prototype.updateDropDown = function (prop, id) {
      var itemProp = getItem(this.parent.tabs, id);
      if (!itemProp) {
        return;
      }
      this.updateDropDownProp(itemProp, prop, id);
    };
    /**
     * Updates the dropdown properties.
     *
     * @param {itemProps} itemProp - Gets the property of ribbon dropdown item.
     * @param {RibbonDropDownSettingsModel} prop - Gets the property of dropdown.
     * @param {string} id - Gets the ID of dropdown item.
     * @returns {void}
     * @hidden
     */
    RibbonDropDown.prototype.updateDropDownProp = function (itemProp, prop, id) {
      sf.base.merge(itemProp.item.checkBoxSettings, prop);
      var inputEle = getItemElement(this.parent, itemProp, id);
      if (!inputEle) {
        return;
      }
      var dropDownObj = sf.base.getComponent(inputEle, itemProp.item.dropDownSettings.isDropDownButton ? sf.splitbuttons.DropDownButton : sf.splitbuttons.SplitButton);
      if (prop.cssClass) {
        prop.cssClass = (ITEM_VERTICAL_CENTER + SPACE + prop.cssClass).trim();
        prop.cssClass = itemProp.item.size === 'Large' ? (VERTICAL_DDB + SPACE + prop.cssClass).trim() : prop.cssClass;
      }
      if (prop.content) {
        prop.content = itemProp.item.size === 'Small' ? '' : prop.content;
      }
      dropDownObj.setProperties(prop);
    };
    /**
     * Updated DropDown size
     *
     * @param {HTMLElement} element - Gets the dropdown element.
     * @param {RibbonItemModel} item - Gets the ribbon item model.
     * @returns {void}
     * @hidden
     */
    RibbonDropDown.prototype.updateDropDownSize = function (element, item) {
      var control = sf.base.getComponent(element, item.dropDownSettings.isDropDownButton ? sf.splitbuttons.DropDownButton : sf.splitbuttons.SplitButton);
      var cssClass = control.cssClass.split(SPACE);
      if (item.size === 'Large') {
        cssClass.push(VERTICAL_DDB);
      } else {
        cssClass = cssClass.filter(function (value) {
          return value !== VERTICAL_DDB;
        });
      }
      control.setProperties({
        iconPosition: item.size === 'Large' ? 'Top' : 'Left'
      });
      control.setProperties({
        content: item.size === 'Small' ? '' : item.dropDownSettings.content
      });
      control.setProperties({
        cssClass: cssClass.join(SPACE)
      });
      if (item.dropDownSettings.isDropDownButton) {
        control.refresh();
      }
    };
    return RibbonDropDown;
  }();

  /**
   * Gets index value.
   *
   * @param {Array} arr - Gets the array to find index.
   * @param {boolean} condition - Defines whether index matches with the value.
   * @returns {number} - Gets the index value.
   */
  function getIndex(arr, condition) {
    for (var i = 0; i < arr.length; i++) {
      if (condition(arr[parseInt(i.toString(), 10)], i)) {
        return i;
      }
    }
    return -1;
  }
  /**
   * Gets the ribbon item
   *
   * @param {RibbonTabModel} tabs - Gets the ribbon tab model.
   * @param {string} id - Gets the ID of the tab.
   * @returns {itemProps} - Gets the ribbon item.
   */
  function getItem(tabs, id) {
    for (var i = 0; i < tabs.length; i++) {
      var tab = tabs[parseInt(i.toString(), 10)];
      for (var j = 0; j < tab.groups.length; j++) {
        var group = tab.groups[parseInt(j.toString(), 10)];
        for (var k = 0; k < group.collections.length; k++) {
          var collection = group.collections[parseInt(k.toString(), 10)];
          for (var l = 0; l < collection.items.length; l++) {
            var item = collection.items[parseInt(l.toString(), 10)];
            if (item.id === id) {
              return {
                item: item,
                collection: collection,
                group: group,
                tabIndex: i,
                groupIndex: j,
                collectionIndex: k,
                itemIndex: l
              };
            }
          }
        }
      }
    }
    return null;
  }
  /**
   * Gets the ribbon collection.
   *
   * @param {RibbonTabModel} tabs - Gets the ribbon tab model.
   * @param {string} id - Gets the ID of the tab.
   * @returns {itemProps} - Gets the ribbon collection.
   */
  function getCollection(tabs, id) {
    for (var i = 0; i < tabs.length; i++) {
      var tab = tabs[parseInt(i.toString(), 10)];
      for (var j = 0; j < tab.groups.length; j++) {
        var group = tab.groups[parseInt(j.toString(), 10)];
        for (var k = 0; k < group.collections.length; k++) {
          var collection = group.collections[parseInt(k.toString(), 10)];
          if (collection.id === id) {
            return {
              collection: collection,
              group: group,
              tabIndex: i,
              groupIndex: j,
              collectionIndex: k
            };
          }
        }
      }
    }
    return null;
  }
  /**
   * Gets the ribbon group.
   *
   * @param {RibbonTabModel} tabs - Gets the ribbon tab model.
   * @param {string} id - Gets the ID of the tab.
   * @returns {itemProps} - Gets the ribbon group.
   */
  function getGroup(tabs, id) {
    for (var i = 0; i < tabs.length; i++) {
      var tab = tabs[parseInt(i.toString(), 10)];
      for (var j = 0; j < tab.groups.length; j++) {
        var group = tab.groups[parseInt(j.toString(), 10)];
        if (group.id === id) {
          return {
            group: group,
            tabIndex: i,
            groupIndex: j
          };
        }
      }
    }
    return null;
  }
  /**
   * @param {HTMLElement} element - Gets the element to be destroyed.
   * @param {string} moduleName - Gets the module name.
   * @returns {void}
   */
  function destroyControl(element, moduleName) {
    var control = sf.base.getComponent(element, moduleName);
    control.destroy();
  }
  /**
   * Updates common properties.
   *
   * @param {HTMLElement} element - Gets the element to be updated.
   * @param {string} moduleName - Gets the module name.
   * @param {commonProperties} commonProp - Gets the common properties to be updated.
   * @returns {void}
   */
  function updateCommonProperty(element, moduleName, commonProp) {
    var control = sf.base.getComponent(element, moduleName);
    control.setProperties(commonProp);
  }
  /**
   * Updates disabled control.
   *
   * @param {HTMLElement} element - Gets the element to be disabled.
   * @param {string} moduleName - Gets the module name.
   * @param {boolean} disable - Defines whether the control to be disabled or not.
   * @returns {void}
   */
  function updateControlDisabled(element, moduleName, disable) {
    var control = sf.base.getComponent(element, moduleName);
    control.setProperties(moduleName === 'combobox' ? {
      enabled: !disable
    } : {
      disabled: disable
    });
  }
  /**
   * Gets the ribbon item element.
   *
   * @param {Ribbon} parent - Gets the parent element.
   * @param {itemProps} itemProp - Gets the ribbon item.
   * @param {string} id - Gets the ID of the item.
   * @returns {HTMLElement} - Gets the ribbon item element.
   */
  function getItemElement(parent, itemProp, id) {
    var contentEle = parent.tabObj.items[itemProp.tabIndex].content;
    if (parent.tabs[itemProp.tabIndex].groups[itemProp.groupIndex].isCollapsed) {
      contentEle = parent.ribbonDropDownModule.getOverflowDropDownPopup(itemProp, contentEle);
    }
    return contentEle.querySelector('#' + id);
  }
  /**
   * @param {RibbonTooltipModel} tooltip - Gets the property of tooltip.
   * @returns {boolean} - Gets whether the tooltip is present or not.
   */
  function isTooltipPresent(tooltip) {
    return tooltip.content || tooltip.iconCss || tooltip.title || tooltip.id || tooltip.cssClass ? true : false;
  }
  /**
   * Sets content for tooltip.
   *
   * @param {TooltipEventArgs} args - Gets the argument of tooltip.
   * @param {Tooltip} tooltip - Gets the tooltip to set the content.
   * @param {ribbonTooltipData} tooltipData - Gets the tooltip data.
   * @returns {void}
   */
  function setToolTipContent(args, tooltip, tooltipData) {
    var targetId = args.target.getAttribute('id');
    var dataObj = tooltipData.filter(function (e) {
      return e.id === targetId;
    })[0];
    var data = dataObj.data;
    var content = tooltip.createElement('div', {
      id: data.id ? RIBBON_TOOLTIP_CONTAINER + '_' + data.id : RIBBON_TOOLTIP_CONTAINER
    });
    tooltip.element.append(content);
    if (data.title) {
      var header = tooltip.createElement('div', {
        innerHTML: data.title,
        className: RIBBON_TOOLTIP_TITLE
      });
      content.appendChild(header);
    }
    var textContainer = tooltip.createElement('div', {
      className: RIBBON_TEXT_CONTAINER
    });
    content.appendChild(textContainer);
    if (data.iconCss) {
      var customCss = tooltip.createElement('div', {
        className: data.cssClass ? data.cssClass + ' ' + data.iconCss + ' ' + RIBBON_TOOLTIP_ICON : data.iconCss + ' ' + RIBBON_TOOLTIP_ICON
      });
      textContainer.appendChild(customCss);
    }
    if (data.content) {
      var tooltipContent = tooltip.createElement('div', {
        innerHTML: data.content,
        className: RIBBON_TOOLTIP_CONTENT
      });
      textContainer.appendChild(tooltipContent);
    }
    tooltip.setProperties({
      content: content
    });
  }

  /**
   * Defines the items of Ribbon.
   */
  var RibbonFileMenu = /** @class */function () {
    function RibbonFileMenu(parent) {
      this.parent = parent;
    }
    RibbonFileMenu.prototype.getModuleName = function () {
      return 'ribbonFileMenu';
    };
    RibbonFileMenu.prototype.destroy = function () {
      if (this.fileMenuDDB) {
        this.destroyDDB();
      }
      this.parent = null;
    };
    /**
     * Creates File Menu
     *
     * @param {FileMenuSettingsModel} fileMenuOptions - Gets the property of filemenu.
     * @returns {void}
     * @hidden
     */
    RibbonFileMenu.prototype.createFileMenu = function (fileMenuOptions) {
      var _this = this;
      if (!fileMenuOptions.visible) {
        return;
      }
      this.ddbElement = this.parent.createElement('button', {
        id: this.parent.element.id + RIBBON_FILE_MENU_ID,
        className: 'e-ribbon-file-menu'
      });
      var tabEle = this.parent.tabObj.element;
      var toolbarEle = tabEle.querySelector('.e-toolbar');
      tabEle.insertBefore(this.ddbElement, toolbarEle);
      this.fileMenuDDB = new sf.splitbuttons.DropDownButton({
        content: fileMenuOptions.text,
        cssClass: 'e-caret-hide',
        created: function created() {
          tabEle.style.setProperty(RIBBON_FILE_MENU_WIDTH, _this.ddbElement.offsetWidth + 'px');
        },
        beforeClose: this.ddbBeforeEvent.bind(this, false),
        beforeOpen: this.ddbBeforeEvent.bind(this, true),
        close: this.ddbAfterEvent.bind(this, false),
        open: this.ddbAfterEvent.bind(this, true)
      }, this.ddbElement);
      if (this.parent.fileMenu.popupTemplate) {
        this.fileMenuDDB.setProperties({
          target: this.parent.fileMenu.popupTemplate
        });
      } else {
        this.createRibbonMenu(fileMenuOptions);
      }
      this.parent.tabObj.refreshActiveTabBorder();
      if (isTooltipPresent(fileMenuOptions.tooltip)) {
        this.ddbElement.classList.add(RIBBON_TOOLTIP_TARGET);
        this.parent.tooltipData.push({
          id: this.ddbElement.id,
          data: fileMenuOptions.tooltip
        });
      }
    };
    RibbonFileMenu.prototype.ddbBeforeEvent = function (isOpen, args) {
      var event = isOpen ? this.parent.fileMenu.beforeOpen : this.parent.fileMenu.beforeClose;
      if (event) {
        var eventArgs = {
          cancel: args.cancel,
          element: args.element,
          event: args.event
        };
        event.call(this, eventArgs);
        args.cancel = eventArgs.cancel;
      }
    };
    RibbonFileMenu.prototype.ddbAfterEvent = function (isOpen, args) {
      var event = isOpen ? this.parent.fileMenu.open : this.parent.fileMenu.close;
      if (event) {
        var eventArgs = {
          element: args.element
        };
        event.call(this, eventArgs);
      }
    };
    //Clone RibbonMenuItems before assigning to avoid reference issues.
    RibbonFileMenu.prototype.cloneMenuItem = function (items) {
      var itemsList = [];
      for (var i = 0; i < items.length; i++) {
        var item = items[parseInt(i.toString(), 10)];
        itemsList.push({
          iconCss: item.iconCss,
          id: item.id,
          separator: item.separator,
          text: item.text,
          url: item.url,
          items: this.cloneMenuItem(item.items)
        });
      }
      return itemsList;
    };
    RibbonFileMenu.prototype.createRibbonMenu = function (menuOptions) {
      var ulElem = this.parent.createElement('ul', {
        id: this.parent.element.id + RIBBON_FILE_MENU_ID
      });
      this.fileMenuDDB.setProperties({
        target: ulElem
      });
      this.menuctrl = new sf.navigations.Menu({
        orientation: 'Vertical',
        cssClass: 'e-ribbon-menu',
        animationSettings: menuOptions.animationSettings,
        items: this.cloneMenuItem(menuOptions.menuItems),
        showItemOnClick: menuOptions.showItemOnClick,
        template: menuOptions.itemTemplate,
        beforeClose: this.menuBeforeEvent.bind(this, false),
        beforeOpen: this.menuBeforeEvent.bind(this, true),
        beforeItemRender: this.beforeItemRender.bind(this),
        onClose: this.menuAfterEvent.bind(this, false),
        onOpen: this.menuAfterEvent.bind(this, true),
        select: this.menuSelect.bind(this)
      }, ulElem);
    };
    RibbonFileMenu.prototype.menuBeforeEvent = function (isOpen, args) {
      var event = isOpen ? this.parent.fileMenu.beforeOpen : this.parent.fileMenu.beforeClose;
      if (event) {
        var eventArgs = {
          cancel: args.cancel,
          element: args.element,
          event: args.event,
          items: args.items,
          parentItem: args.parentItem
        };
        event.call(this, eventArgs);
        args.cancel = eventArgs.cancel;
      }
    };
    RibbonFileMenu.prototype.menuAfterEvent = function (isOpen, args) {
      var event = isOpen ? this.parent.fileMenu.open : this.parent.fileMenu.close;
      if (event) {
        var eventArgs = {
          element: args.element,
          items: args.items,
          parentItem: args.parentItem
        };
        event.call(this, eventArgs);
      }
    };
    RibbonFileMenu.prototype.beforeItemRender = function (args) {
      var event = this.parent.fileMenu.beforeItemRender;
      if (event) {
        var eventArgs = {
          element: args.element,
          item: args.item
        };
        event.call(this, eventArgs);
      }
    };
    RibbonFileMenu.prototype.menuSelect = function (args) {
      var event = this.parent.fileMenu.select;
      if (event) {
        var eventArgs = {
          element: args.element,
          item: args.item,
          event: args.event
        };
        event.call(this, eventArgs);
      }
    };
    /**
     * Update FileMenu
     *
     * @param {FileMenuSettingsModel} fileMenuOptions - Gets the property of filemenu.
     * @returns {void}
     * @hidden
     */
    RibbonFileMenu.prototype.updateFileMenu = function (fileMenuOptions) {
      var _this = this;
      if (fileMenuOptions.visible) {
        if (this.fileMenuDDB) {
          if (fileMenuOptions.text) {
            this.fileMenuDDB.setProperties({
              content: fileMenuOptions.text
            });
            this.parent.tabObj.element.style.setProperty(RIBBON_FILE_MENU_WIDTH, this.ddbElement.offsetWidth + 'px');
          }
          if (fileMenuOptions.popupTemplate) {
            if (this.menuctrl) {
              this.destroyMenu();
            }
            this.fileMenuDDB.setProperties({
              target: fileMenuOptions.popupTemplate
            });
          } else {
            if (this.menuctrl) {
              this.menuctrl.setProperties({
                animationSettings: fileMenuOptions.animationSettings,
                items: this.cloneMenuItem(fileMenuOptions.menuItems),
                showItemOnClick: fileMenuOptions.showItemOnClick,
                template: fileMenuOptions.itemTemplate
              });
            } else {
              this.createRibbonMenu(fileMenuOptions);
            }
          }
        } else {
          this.createFileMenu(fileMenuOptions);
        }
      } else {
        if (this.fileMenuDDB) {
          var index = getIndex(this.parent.tooltipData, function (e) {
            return e.id === _this.ddbElement.id;
          });
          if (index !== -1) {
            this.ddbElement.classList.remove(RIBBON_TOOLTIP_TARGET);
            this.parent.tooltipData.splice(index, 1);
          }
          this.destroyDDB();
        }
      }
      this.parent.tabObj.refreshActiveTabBorder();
    };
    RibbonFileMenu.prototype.destroyMenu = function () {
      if (this.menuctrl) {
        this.menuctrl.destroy();
        this.menuctrl = null;
      }
    };
    RibbonFileMenu.prototype.destroyDDB = function () {
      var tabEle = this.parent.tabObj.element;
      tabEle.style.removeProperty(RIBBON_FILE_MENU_WIDTH);
      this.destroyMenu();
      this.fileMenuDDB.destroy();
      this.fileMenuDDB = null;
      sf.base.remove(this.ddbElement);
      this.ddbElement = null;
    };
    RibbonFileMenu.prototype.addItems = function (items, target, isAfter, isUniqueId) {
      if (isAfter) {
        this.menuctrl.insertAfter(items, target, isUniqueId);
      } else {
        this.menuctrl.insertBefore(items, target, isUniqueId);
      }
      this.parent.fileMenu.setProperties({
        menuItems: this.menuctrl.items
      }, true);
    };
    RibbonFileMenu.prototype.removeItems = function (items, isUniqueId) {
      this.menuctrl.removeItems(items, isUniqueId);
      this.parent.fileMenu.setProperties({
        menuItems: this.menuctrl.items
      }, true);
    };
    RibbonFileMenu.prototype.enableItems = function (items, isUniqueId) {
      this.menuctrl.enableItems(items, true, isUniqueId);
      this.parent.fileMenu.setProperties({
        menuItems: this.menuctrl.items
      }, true);
    };
    RibbonFileMenu.prototype.disableItems = function (items, isUniqueId) {
      this.menuctrl.enableItems(items, false, isUniqueId);
      this.parent.fileMenu.setProperties({
        menuItems: this.menuctrl.items
      }, true);
    };
    RibbonFileMenu.prototype.setItem = function (item, id, isUniqueId) {
      this.menuctrl.setItem(item, id, isUniqueId);
      this.menuctrl.refresh();
      this.parent.fileMenu.setProperties({
        menuItems: this.menuctrl.items
      }, true);
    };
    return RibbonFileMenu;
  }();
  var __extends = undefined && undefined.__extends || function () {
    var _extendStatics12 = function extendStatics(d, b) {
      _extendStatics12 = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };
      return _extendStatics12(d, b);
    };
    return function (d, b) {
      _extendStatics12(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  /**
   * The Ribbon Component is a structured layout to manage tools with tabs and groups.
   */
  var Ribbon = /** @class */function (_super) {
    __extends(Ribbon, _super);
    /**
     * Constructor for creating the widget.
     *
     * @param  {RibbonModel} options - Specifies the ribbon model
     * @param  {string|HTMLDivElement} element - Specifies the target element
     */
    function Ribbon(options, element) {
      return _super.call(this, options, element) || this;
    }
    Ribbon_1 = Ribbon;
    /**
     * Initialize the control rendering.
     *
     * @returns {void}
     * @private
     */
    Ribbon.prototype.render = function () {
      this.initialize();
    };
    Ribbon.prototype.preRender = function () {
      Ribbon_1.Inject(RibbonButton, RibbonCheckBox, RibbonDropDown, RibbonComboBox, RibbonFileMenu);
      this.idIndex = 0;
      this.tooltipData = [];
      this.isAddRemove = false;
    };
    /**
     * Get the properties to be maintained in the persisted state.
     *
     * @returns {string} - Persist data
     */
    Ribbon.prototype.getPersistData = function () {
      return this.addOnPersist([]);
    };
    /**
     * Get component name.
     *
     * @returns {string} - Module name
     * @private
     */
    Ribbon.prototype.getModuleName = function () {
      return 'ribbon';
    };
    /**
     * To provide the array of modules needed for component rendering
     *
     * @returns {ModuleDeclaration[]} - returns module declaration.
     * @hidden
     */
    Ribbon.prototype.requiredModules = function () {
      var modules = [];
      modules.push({
        member: 'ribbonButton',
        args: [this]
      }, {
        member: 'ribbonDropDown',
        args: [this]
      }, {
        member: 'ribbonCheckBox',
        args: [this]
      }, {
        member: 'ribbonColorPicker',
        args: [this]
      }, {
        member: 'ribbonComboBox',
        args: [this]
      }, {
        member: 'ribbonFileMenu',
        args: [this]
      });
      return modules;
    };
    Ribbon.prototype.initialize = function () {
      if (!this.element.id) {
        this.element.id = sf.base.getUniqueID('e-' + this.getModuleName());
      }
      if (this.cssClass) {
        sf.base.addClass([this.element], this.cssClass.split(SPACE));
      }
      this.element.style.width = sf.base.formatUnit(this.width);
      this.renderTabs();
      this.ribbonFileMenuModule.createFileMenu(this.fileMenu);
      this.createHelpPaneTemplate();
      this.createTooltip();
      this.wireEvents();
    };
    Ribbon.prototype.createTooltip = function () {
      this.ribbonTooltip = new sf.popups.Tooltip({
        cssClass: (RIBBON_TOOLTIP + ' ' + this.cssClass).trim(),
        target: '.' + RIBBON_TOOLTIP_TARGET,
        beforeRender: beforeTooltipRender.bind(this)
      });
      this.ribbonTooltip.appendTo(this.element);
      /**
       * @param {TooltipEventArgs} args - Gets the tooltip argument.
       * @returns {void}
       */
      function beforeTooltipRender(args) {
        setToolTipContent(args, this.ribbonTooltip, this.tooltipData);
      }
    };
    Ribbon.prototype.wireEvents = function () {
      sf.base.EventHandler.add(window, 'resize', this.resizeHandler, this);
    };
    Ribbon.prototype.resizeHandler = function () {
      this.checkOverflow();
      if (this.scrollModule) {
        var scrollEle = this.tabObj.element.querySelector('.' + HORIZONTAL_SCROLLBAR);
        this.scrollModule.scrollStep = scrollEle.offsetWidth;
      }
    };
    Ribbon.prototype.renderTabs = function () {
      this.tabsInternal = this.tabs.slice();
      this.tabsInternal = this.checkID(this.tabsInternal, 'tab', this.element.id);
      this.setProperties({
        tabs: this.tabsInternal
      }, true);
      var tabEle = this.createElement('div', {
        id: this.element.id + TAB_ID
      });
      this.element.appendChild(tabEle);
      this.validateItemSize();
      var tabItems = this.createTabItems(this.tabs);
      this.tabObj = new sf.navigations.Tab({
        cssClass: RIBBON_TAB,
        selectedItem: this.selectedTab,
        overflowMode: 'Popup',
        width: this.width,
        items: tabItems,
        created: this.tabCreated.bind(this),
        selected: this.ribbonTabSelected.bind(this),
        selecting: this.ribbonTabSelecting.bind(this)
      });
      this.tabObj.appendTo(tabEle);
      //Set the width value as "0px" with unit for proper calculation.
      this.element.style.setProperty(RIBBON_FILE_MENU_WIDTH, '0px');
      var toolbarEle = tabEle.querySelector('.e-toolbar');
      var toolbar = sf.base.getComponent(toolbarEle, sf.navigations.Toolbar);
      toolbar.setProperties({
        width: 'calc(100% - var(--fileMenuWidth) - var(--rightTemplateWidth))'
      });
      this.element.classList[this.isMinimized ? 'add' : 'remove'](RIBBON_MINIMIZE);
    };
    Ribbon.prototype.minimize = function (val) {
      var _this = this;
      var eventArgs = {
        cancel: false
      };
      this.trigger(val ? 'ribbonCollapsing' : 'ribbonExpanding', eventArgs, function (args) {
        if (args.cancel) {
          return;
        }
        _this.setProperties({
          isMinimized: val
        }, true);
        _this.element.classList[_this.isMinimized ? 'add' : 'remove'](RIBBON_MINIMIZE);
      });
    };
    Ribbon.prototype.toggleLayout = function () {
      this.setProperties({
        activeLayout: this.activeLayout === 'Simplified' ? 'Classic' : 'Simplified'
      }, true);
      this.collapseButton.classList[this.activeLayout === 'Simplified' ? 'add' : 'remove'](RIBBON_EXPAND_BUTTON);
      this.element.classList[this.activeLayout === 'Simplified' ? 'add' : 'remove'](RIBBON_SIMPLIFIED_MODE);
      this.switchLayout();
    };
    Ribbon.prototype.tabCreated = function () {
      this.addExpandCollapse();
      this.renderInitialTab(this.tabObj.selectedItem);
    };
    Ribbon.prototype.ribbonTabSelected = function (e) {
      var eventArgs = {
        previousIndex: e.previousIndex,
        selectedIndex: e.selectedIndex
      };
      this.trigger('tabSelected', eventArgs);
      this.isAddRemove = false;
      this.setProperties({
        selectedTab: e.selectedIndex
      }, true);
      this.checkOverflow(e.selectedContent);
      if (this.activeLayout === 'Simplified' && this.overflowDDB) {
        var tabContainer = this.overflowDDB.target.querySelector('.e-ribbon-active');
        if (tabContainer) {
          tabContainer.classList.remove('e-ribbon-active');
        }
        var overflowTarget = this.overflowDDB.target;
        overflowTarget.querySelector("[data-index='" + e.selectedIndex + "']").classList.add('e-ribbon-active');
      }
    };
    Ribbon.prototype.checkOverflow = function (activeContent) {
      if (activeContent === void 0) {
        activeContent = null;
      }
      if (!activeContent) {
        activeContent = this.tabObj.element.querySelector('#' + this.tabs[this.selectedTab].id + CONTENT_ID);
      }
      var tabContent = activeContent.closest('.' + TAB_CONTENT);
      var isOverFlow = tabContent.offsetWidth < activeContent.offsetWidth;
      if (isOverFlow && !this.scrollModule) {
        if (this.activeLayout === 'Classic') {
          // Defines whether the shrinking is breaked due to insufficient space.
          var isBreak = false;
          isBreak = this.checkGroupShrinking(tabContent, activeContent, true);
          if (!isBreak && tabContent.offsetWidth < activeContent.offsetWidth) {
            isBreak = this.checkGroupShrinking(tabContent, activeContent, false);
          }
          if (tabContent.offsetWidth < activeContent.offsetWidth) {
            this.createOverflowDropdown(tabContent, activeContent);
          }
        } else {
          this.createSimplfiedOverflow(tabContent, activeContent, this.selectedTab);
        }
        //Adds Scroll if the tabwidth is less the content width even after adding overflow dropdown.
        if (tabContent.offsetWidth < activeContent.offsetWidth && !this.scrollModule) {
          this.scrollModule = new sf.navigations.HScroll({}, this.tabObj.element.querySelector('.' + TAB_CONTENT));
        }
      } else if (!isOverFlow) {
        this.destroyScroll();
        if (this.activeLayout === 'Classic') {
          var isBreak = false;
          isBreak = this.removeOverflowDropdown(tabContent, activeContent);
          //Check for expanding small items to medium items.
          if (!isBreak && tabContent.offsetWidth > activeContent.offsetWidth) {
            isBreak = this.checkGroupExpanding(tabContent, activeContent, true);
          }
          //Check for expanding medium items to large items.
          if (!isBreak && tabContent.offsetWidth > activeContent.offsetWidth) {
            isBreak = this.checkGroupExpanding(tabContent, activeContent, false);
          }
        } else {
          this.removeSimplfiedOverflow(tabContent, activeContent, this.selectedTab);
        }
      }
    };
    Ribbon.prototype.createSimplfiedOverflow = function (tabContent, activeContent, tabIndex) {
      var orderedGroups = this.getGroupResizeOrder(true);
      for (var i = 0; i < orderedGroups.length && tabContent.offsetWidth < activeContent.offsetWidth; i++) {
        var group = orderedGroups[parseInt(i.toString(), 10)];
        var groupContainer = tabContent.querySelector('#' + group.id + CONTAINER_ID);
        for (var j = 0; j < group.collections.length && tabContent.offsetWidth < activeContent.offsetWidth; j++) {
          var collection = group.collections[parseInt(j.toString(), 10)];
          for (var k = collection.items.length; k >= 1 && tabContent.offsetWidth < activeContent.offsetWidth; k--) {
            var item = collection.items[k - 1];
            var itemEle = groupContainer.querySelector('#' + item.id + CONTAINER_ID);
            if (item.simplifiedMode === 'Auto' && !sf.base.isNullOrUndefined(itemEle)) {
              itemEle.setAttribute('expanded-width', activeContent.offsetWidth.toString());
              this.createOverflowPopup(tabIndex, group.enableGroupOverflow, group.id, group.header, itemEle, groupContainer);
            }
          }
        }
      }
    };
    Ribbon.prototype.removeSimplfiedOverflow = function (tabContent, activeContent, tabIndex, isClear) {
      if (isClear === void 0) {
        isClear = false;
      }
      var orderedGroups = this.getGroupResizeOrder(false);
      for (var i = 0; i < orderedGroups.length; i++) {
        var group = orderedGroups[parseInt(i.toString(), 10)];
        for (var j = 0; j < group.collections.length; j++) {
          var collection = group.collections[parseInt(j.toString(), 10)];
          var overflowDDB = void 0;
          var overflowtarget = void 0;
          var ofGroupContainer = void 0;
          if (group.enableGroupOverflow) {
            var overflowDDBEle = tabContent.querySelector('#' + group.id + GROUPOF_BUTTON_ID);
            if (overflowDDBEle) {
              overflowDDB = sf.base.getInstance(overflowDDBEle, sf.splitbuttons.DropDownButton);
              overflowtarget = overflowDDB.target;
            }
          } else {
            overflowDDB = this.overflowDDB;
            if (overflowDDB) {
              overflowtarget = this.overflowDDB.target;
              ofGroupContainer = overflowtarget.querySelector('#' + group.id + CONTAINER_ID);
            }
          }
          for (var k = 0; k < collection.items.length && !isClear && tabContent.offsetWidth > activeContent.offsetWidth; k++) {
            var item = collection.items[parseInt(k.toString(), 10)];
            var popupEle = void 0;
            if (overflowtarget) {
              popupEle = overflowtarget.querySelector('#' + item.id + CONTAINER_ID);
            }
            if (item.simplifiedMode === 'Auto' && !sf.base.isNullOrUndefined(popupEle)) {
              var width = parseInt(popupEle.getAttribute('expanded-width'), 10);
              if (!isClear && tabContent.offsetWidth < width) {
                break;
              }
              var groupEle = tabContent.querySelector('#' + collection.id);
              groupEle.append(popupEle);
              if (!group.enableGroupOverflow) {
                if (ofGroupContainer.childElementCount === 1) {
                  ofGroupContainer.remove();
                }
                var tabContainer = overflowtarget.querySelector('#' + this.tabs[parseInt(tabIndex.toString(), 10)].id + OVERFLOW_ID);
                if (tabContainer.childElementCount === 0) {
                  tabContainer.remove();
                }
              }
            }
          }
          if (group.enableGroupOverflow && overflowDDB) {
            if (overflowtarget.childElementCount === 0) {
              this.removeOverflowButton(overflowDDB);
            }
          }
        }
        if (this.overflowDDB) {
          var overflowEle = this.overflowDDB.target;
          if (overflowEle.childElementCount === 0) {
            this.removeOverflowButton(this.overflowDDB);
            this.overflowDDB = null;
          }
        }
      }
    };
    Ribbon.prototype.createOverflowPopup = function (tabIndex, isGroupOF, groupId, groupHeader, itemEle, groupContainer) {
      if (isGroupOF) {
        var overflowDDB = groupContainer.querySelector('#' + groupId + GROUPOF_BUTTON_ID);
        if (!overflowDDB) {
          var groupOFButton = this.addOverflowButton(groupId + GROUPOF_BUTTON_ID);
          groupOFButton.element.classList.add(RIBBON_GROUP_OF_BUTTON);
          groupContainer.appendChild(groupOFButton.element);
          var overflowtarget = groupOFButton.target;
          overflowtarget.append(itemEle);
        } else {
          var groupOFButton = sf.base.getInstance(overflowDDB, sf.splitbuttons.DropDownButton);
          var overflowtarget = groupOFButton.target;
          overflowtarget.append(itemEle);
        }
      } else {
        if (!this.overflowDDB) {
          this.overflowDDB = this.addOverflowButton(this.tabObj.element.id + OVRLOF_BUTTON_ID);
          this.tabObj.element.appendChild(this.overflowDDB.element);
          this.overflowDDB.element.classList.add(RIBBON_OVERALL_OF_BUTTON);
          this.createTabContainer(groupId, groupHeader, itemEle, tabIndex);
        } else {
          var overflowEle = this.overflowDDB.target;
          var tabContainer = overflowEle.querySelector('#' + this.tabs[parseInt(tabIndex.toString(), 10)].id + OVERFLOW_ID);
          if (tabContainer) {
            var ofGroupContainer = overflowEle.querySelector('#' + groupId + CONTAINER_ID);
            if (!ofGroupContainer) {
              ofGroupContainer = this.createGroupContainer(groupId, groupHeader);
              tabContainer.append(ofGroupContainer);
            }
            ofGroupContainer.append(itemEle);
          } else {
            this.createTabContainer(groupId, groupHeader, itemEle, tabIndex);
          }
        }
      }
    };
    Ribbon.prototype.createTabContainer = function (groupId, groupHeader, itemEle, tabIndex) {
      var tabContainer = this.createElement('div', {
        id: this.tabs[parseInt(tabIndex.toString(), 10)].id + OVERFLOW_ID,
        className: RIBBON_OF_TAB_CONTAINER
      });
      var overflowtarget = this.overflowDDB.target;
      overflowtarget.append(tabContainer);
      tabContainer.setAttribute('data-index', tabIndex.toString());
      var ofGroupContainer = this.createGroupContainer(groupId, groupHeader);
      ofGroupContainer.append(itemEle);
      tabContainer.append(ofGroupContainer);
      if (tabIndex === this.selectedTab) {
        tabContainer.classList.add(RIBBON_TAB_ACTIVE);
      }
    };
    Ribbon.prototype.checkGroupShrinking = function (tabContent, activeContent, isLarge) {
      var isOverFlow = true;
      var isBreak = false;
      var tab = this.tabs[this.selectedTab];
      for (var j = tab.groups.length - 1; isOverFlow && j >= 0; j--) {
        isBreak = isLarge ? this.checkLargeToMedium(tab, j, tabContent, activeContent) : this.checkMediumToSmall(tab, j, tabContent, activeContent);
        isOverFlow = !isBreak && tabContent.offsetWidth < activeContent.offsetWidth;
      }
      return isBreak;
    };
    Ribbon.prototype.checkLargeToMedium = function (tab, groupIndex, tabContent, activeContent, shouldSkip) {
      var _this = this;
      if (shouldSkip === void 0) {
        shouldSkip = false;
      }
      var group = tab.groups[parseInt(groupIndex.toString(), 10)];
      if (group.isCollapsed && !shouldSkip) {
        return false;
      }
      var canReduceCollection = function canReduceCollection(collection) {
        return collection.items.length === 1 && [exports.RibbonAllowedSize.All, exports.RibbonAllowedSize.LargeMedium].indexOf(collection.items[0].allowedSizes) !== -1 && collection.items[0].size === exports.RibbonItemSize.Large;
      };
      var canReduceItem = function canReduceItem(item) {
        return [exports.RibbonAllowedSize.All, exports.RibbonAllowedSize.LargeMedium].indexOf(item.allowedSizes) !== -1 && item.size === exports.RibbonItemSize.Large;
      };
      var createShrinkEle = function createShrinkEle(id, firstItem, start, end) {
        var shrinkEle = _this.createElement('div', {
          className: 'e-ribbon-shrink' + SPACE + RIBBON_ROW,
          id: id + '_shrink_container' + start,
          attrs: {
            'data-start': start.toString(),
            'data-end': end.toString()
          }
        });
        firstItem.parentElement.insertBefore(shrinkEle, firstItem);
        if (!shouldSkip) {
          shrinkEle.setAttribute('data-large-width', activeContent.offsetWidth.toString());
        }
        return shrinkEle;
      };
      var moveItemToColumn = function moveItemToColumn(start, end) {
        var collection = _this.tabs[parseInt(_this.selectedTab.toString(), 10)].groups[parseInt(groupIndex.toString(), 10)].collections[0];
        var firstItem = activeContent.querySelector('#' + collection.items[parseInt(start.toString(), 10)].id + CONTAINER_ID);
        var shrinkEle = shouldSkip ? activeContent.querySelector('#' + collection.id + '_shrink_container' + start) : createShrinkEle(collection.id, firstItem, start, end);
        for (var i = start; i <= end; i++) {
          var item = collection.items[parseInt(i.toString(), 10)];
          var ele = activeContent.querySelector('#' + item.id + CONTAINER_ID);
          shrinkEle.appendChild(ele);
          item.setProperties({
            size: exports.RibbonItemSize.Medium
          }, true);
          _this.setItemSize(ele.querySelector('#' + item.id), item);
        }
      };
      var moveCollectionToColumn = function moveCollectionToColumn(start, end) {
        var group = _this.tabs[parseInt(_this.selectedTab.toString(), 10)].groups[parseInt(groupIndex.toString(), 10)];
        var firstItem = activeContent.querySelector('#' + group.collections[parseInt(start.toString(), 10)].id);
        var shrinkEle = shouldSkip ? activeContent.querySelector('#' + group.id + '_shrink_container' + start) : createShrinkEle(group.id, firstItem, start, end);
        for (var i = start; i <= end; i++) {
          var collection = group.collections[parseInt(i.toString(), 10)];
          var ele = activeContent.querySelector('#' + collection.id);
          shrinkEle.appendChild(ele);
          collection.items[0].setProperties({
            size: exports.RibbonItemSize.Medium
          }, true);
          _this.setItemSize(ele.querySelector('#' + collection.items[0].id), collection.items[0]);
        }
      };
      var orientation = group.orientation;
      if (orientation === exports.ItemOrientation.Column) {
        for (var k = group.collections.length - 1; k > 0; k--) {
          //to avoid negative index while checking for the second collection
          if (k - 1 >= 0 && canReduceCollection(group.collections[parseInt(k.toString(), 10)])) {
            if (canReduceCollection(group.collections[k - 1])) {
              if (k - 2 >= 0 && canReduceCollection(group.collections[k - 2])) {
                moveCollectionToColumn(k - 2, k);
              } else {
                moveCollectionToColumn(k - 1, k);
              }
              k -= 2;
              if (!shouldSkip && tabContent.offsetWidth > activeContent.offsetWidth) {
                return true;
              }
            } else {
              k--;
            }
          }
        }
      } else {
        if (group.collections.length === 1) {
          var collection = group.collections[0];
          for (var k = collection.items.length - 1; k > 0; k--) {
            //to avoid negative index while checking for the second item
            if (k - 1 >= 0 && canReduceItem(collection.items[parseInt(k.toString(), 10)])) {
              if (canReduceItem(collection.items[k - 1])) {
                if (k - 2 >= 0 && canReduceItem(collection.items[k - 2])) {
                  moveItemToColumn(k - 2, k);
                } else {
                  moveItemToColumn(k - 1, k);
                }
                k -= 2;
                if (!shouldSkip && tabContent.offsetWidth > activeContent.offsetWidth) {
                  return true;
                }
              } else {
                k--;
              }
            }
          }
        }
      }
      return false;
    };
    Ribbon.prototype.checkMediumToSmall = function (tab, groupIndex, tabContent, activeContent, shouldSkip) {
      var _this = this;
      if (shouldSkip === void 0) {
        shouldSkip = false;
      }
      var group = tab.groups[parseInt(groupIndex.toString(), 10)];
      if (group.isCollapsed && !shouldSkip) {
        return false;
      }
      var orientation = group.orientation;
      var ele = activeContent.querySelector('#' + group.id);
      var shrinkColumns = ele.querySelectorAll('.' + 'e-ribbon-shrink');
      var canReduceItem = function canReduceItem(item) {
        return [exports.RibbonAllowedSize.All, exports.RibbonAllowedSize.MediumSmall].indexOf(item.allowedSizes) !== -1 && item.size === exports.RibbonItemSize.Medium;
      };
      var reduceItemsToSmall = function reduceItemsToSmall(collectionIndex, start, end) {
        var collection = _this.tabs[parseInt(_this.selectedTab.toString(), 10)].groups[parseInt(groupIndex.toString(), 10)].collections[parseInt(collectionIndex.toString(), 10)];
        for (var i = start; i <= end; i++) {
          var item = collection.items[parseInt(i.toString(), 10)];
          var ele_1 = activeContent.querySelector('#' + item.id);
          item.setProperties({
            size: exports.RibbonItemSize.Small
          }, true);
          _this.setItemSize(ele_1, item);
        }
      };
      var reduceCollectionsToSmall = function reduceCollectionsToSmall(index, start, end) {
        var group = _this.tabs[parseInt(_this.selectedTab.toString(), 10)].groups[parseInt(groupIndex.toString(), 10)];
        if (!shouldSkip) {
          shrinkColumns[parseInt(index.toString(), 10)].setAttribute('data-medium-width', activeContent.offsetWidth.toString());
        }
        for (var i = start; i <= end; i++) {
          var collection = group.collections[parseInt(i.toString(), 10)];
          var ele_2 = activeContent.querySelector('#' + collection.items[0].id);
          collection.items[0].setProperties({
            size: exports.RibbonItemSize.Small
          }, true);
          _this.setItemSize(ele_2, collection.items[0]);
        }
      };
      var setWidth = function setWidth(id) {
        if (!shouldSkip) {
          var ele_3 = activeContent.querySelector('#' + id);
          ele_3.setAttribute('data-medium-width', activeContent.offsetWidth.toString());
        }
      };
      if (orientation === exports.ItemOrientation.Column) {
        if (shrinkColumns.length > 0) {
          for (var k = shrinkColumns.length - 1; k >= 0; k--) {
            var start = parseInt(shrinkColumns[parseInt(k.toString(), 10)].getAttribute('data-start'), 10);
            var end = parseInt(shrinkColumns[parseInt(k.toString(), 10)].getAttribute('data-end'), 10);
            //only 2 or 3 itmes alone can be present in shrinked column
            if (canReduceItem(group.collections[parseInt(start.toString(), 10)].items[0]) && canReduceItem(group.collections[start + 1].items[0])) {
              if (end - start === 1) {
                //if only 2 item, the difference will be 1, else check for 3 rd item satus.
                reduceCollectionsToSmall(k, start, end);
              } else if (canReduceItem(group.collections[parseInt(start.toString(), 10)].items[0])) {
                reduceCollectionsToSmall(k, start, end);
              }
              if (!shouldSkip && tabContent.offsetWidth > activeContent.offsetWidth) {
                return true;
              }
            }
          }
        }
        for (var k = group.collections.length - 1; k >= 0; k--) {
          var collection = group.collections[parseInt(k.toString(), 10)];
          //If items length is 1 then, it would have been already check for shrinked column
          if (collection.items.length > 1) {
            if (canReduceItem(collection.items[0]) && canReduceItem(collection.items[1])) {
              if (collection.items.length === 2) {
                setWidth(collection.id);
                reduceItemsToSmall(k, 0, 1);
              } else if (canReduceItem(collection.items[2])) {
                setWidth(collection.id);
                reduceItemsToSmall(k, 0, 2);
              }
              if (!shouldSkip && tabContent.offsetWidth > activeContent.offsetWidth) {
                return true;
              }
            }
          }
        }
      } else {
        if (group.collections.length === 1) {
          if (shrinkColumns.length > 0) {
            for (var k = shrinkColumns.length - 1; k >= 0; k--) {
              var shrinkColumn = shrinkColumns[parseInt(k.toString(), 10)];
              var start = parseInt(shrinkColumn.getAttribute('data-start'), 10);
              var end = parseInt(shrinkColumn.getAttribute('data-end'), 10);
              //only 2 or 3 itmes alone can be present in shrinked column
              if (canReduceItem(group.collections[0].items[parseInt(start.toString(), 10)]) && canReduceItem(group.collections[0].items[start + 1])) {
                if (end - start === 1) {
                  //if only 2 item, the difference will be 1, else check for 3 rd item satus.
                  setWidth(shrinkColumn.id);
                  reduceItemsToSmall(0, start, end);
                } else if (canReduceItem(group.collections[0].items[parseInt(end.toString(), 10)])) {
                  setWidth(shrinkColumn.id);
                  reduceItemsToSmall(0, start, end);
                }
                if (!shouldSkip && tabContent.offsetWidth > activeContent.offsetWidth) {
                  return true;
                }
              }
            }
          }
        } else {
          for (var k = group.collections.length - 1; k >= 0; k--) {
            var collection = group.collections[parseInt(k.toString(), 10)];
            for (var l = collection.items.length - 1; l >= 0; l--) {
              var item = collection.items[parseInt(l.toString(), 10)];
              if (canReduceItem(item)) {
                setWidth(item.id);
                reduceItemsToSmall(k, l, l);
                if (!shouldSkip && tabContent.offsetWidth > activeContent.offsetWidth) {
                  return true;
                }
              }
            }
          }
        }
      }
      return false;
    };
    Ribbon.prototype.checkGroupExpanding = function (tabContent, activeContent, isSmall) {
      var isBreak = false;
      var tab = this.tabs[this.selectedTab];
      for (var j = 0; !isBreak && j < tab.groups.length; j++) {
        isBreak = isSmall ? this.checkSmallToMedium(tab, j, tabContent, activeContent, false, true) : this.checkMediumToLarge(tab, j, tabContent, activeContent, false, true);
      }
      return isBreak;
    };
    Ribbon.prototype.checkSmallToMedium = function (tab, groupIndex, tabContent, activeContent, shouldSkip, shouldClear) {
      var _this = this;
      var group = tab.groups[parseInt(groupIndex.toString(), 10)];
      var orientation = group.orientation;
      var ele = activeContent.querySelector('#' + group.id);
      var shrinkColumns = ele.querySelectorAll('.' + 'e-ribbon-shrink');
      var canExpandItem = function canExpandItem(item) {
        return [exports.RibbonAllowedSize.All, exports.RibbonAllowedSize.MediumSmall].indexOf(item.allowedSizes) !== -1 && item.size === exports.RibbonItemSize.Small;
      };
      var expandItemsToMedium = function expandItemsToMedium(collectionIndex, start, end, parentEle) {
        var collection = _this.tabs[parseInt(_this.selectedTab.toString(), 10)].groups[parseInt(groupIndex.toString(), 10)].collections[parseInt(collectionIndex.toString(), 10)];
        for (var i = start; i <= end; i++) {
          var item = collection.items[parseInt(i.toString(), 10)];
          var ele_4 = parentEle.id === item.id ? parentEle : parentEle.querySelector('#' + item.id);
          item.setProperties({
            size: exports.RibbonItemSize.Medium
          }, true);
          _this.setItemSize(ele_4, item);
        }
      };
      var expandCollectionsToMedium = function expandCollectionsToMedium(start, end) {
        var collections = _this.tabs[parseInt(_this.selectedTab.toString(), 10)].groups[parseInt(groupIndex.toString(), 10)].collections;
        for (var i = start; i <= end; i++) {
          var ele_5 = activeContent.querySelector('#' + collections[parseInt(i.toString(), 10)].items[0].id);
          collections[parseInt(i.toString(), 10)].items[0].setProperties({
            size: exports.RibbonItemSize.Medium
          }, true);
          _this.setItemSize(ele_5, collections[parseInt(i.toString(), 10)].items[0]);
        }
      };
      if (orientation === exports.ItemOrientation.Row) {
        // collection length is 1, then the it wll be covered in shrinked columns
        if (group.collections.length !== 1) {
          for (var k = 0; k < group.collections.length; k++) {
            var collection = group.collections[parseInt(k.toString(), 10)];
            for (var l = 0; l < collection.items.length; l++) {
              var item = collection.items[parseInt(l.toString(), 10)];
              if (canExpandItem(item)) {
                var itemEle = activeContent.querySelector('#' + item.id);
                var valString = itemEle.getAttribute('data-medium-width');
                var value = valString ? parseInt(valString, 10) : null;
                if (value && (shouldSkip || tabContent.offsetWidth > value)) {
                  expandItemsToMedium(k, l, l, itemEle);
                  if (!shouldSkip || shouldClear) {
                    itemEle.removeAttribute('data-medium-width');
                  }
                } else if (value) {
                  return true;
                }
              }
            }
          }
        }
      } else {
        for (var k = 0; k < group.collections.length; k++) {
          //If items length is 1 then, it will be handled in shrinked column
          if (group.collections[parseInt(k.toString(), 10)].items.length > 1) {
            var collection = group.collections[parseInt(k.toString(), 10)];
            var itemEle = activeContent.querySelector('#' + collection.id);
            var valString = itemEle.getAttribute('data-medium-width');
            var value = valString ? parseInt(valString, 10) : null;
            if (value && (shouldSkip || tabContent.offsetWidth > value)) {
              expandItemsToMedium(k, 0, collection.items.length === 2 ? 1 : 2, itemEle);
              if (!shouldSkip || shouldClear) {
                itemEle.removeAttribute('data-medium-width');
              }
            } else if (value) {
              return true;
            }
          }
        }
      }
      if (shrinkColumns.length > 0) {
        for (var k = 0; k < shrinkColumns.length; k++) {
          var shrinkColumn = shrinkColumns[parseInt(k.toString(), 10)];
          var valString = shrinkColumn.getAttribute('data-medium-width');
          var value = valString ? parseInt(valString, 10) : null;
          if (value && (shouldSkip || tabContent.offsetWidth > value)) {
            var start = parseInt(shrinkColumn.getAttribute('data-start'), 10);
            var end = parseInt(shrinkColumn.getAttribute('data-end'), 10);
            if (orientation === exports.ItemOrientation.Row) {
              expandItemsToMedium(0, start, end, shrinkColumn);
            } else {
              expandCollectionsToMedium(start, end);
            }
            if (!shouldSkip || shouldClear) {
              shrinkColumn.removeAttribute('data-medium-width');
            }
          } else if (value) {
            return true;
          }
        }
      }
      return false;
    };
    Ribbon.prototype.checkMediumToLarge = function (tab, groupIndex, tabContent, activeContent, shouldSkip, shouldClear) {
      var _this = this;
      var group = tab.groups[parseInt(groupIndex.toString(), 10)];
      var orientation = group.orientation;
      var ele = activeContent.querySelector('#' + group.id);
      var shrinkColumns = ele.querySelectorAll('.' + 'e-ribbon-shrink');
      if (shrinkColumns.length === 0) {
        return false;
      }
      var expandItemsToLarge = function expandItemsToLarge(start, end, parentEle) {
        var items = _this.tabs[parseInt(_this.selectedTab.toString(), 10)].groups[parseInt(groupIndex.toString(), 10)].collections[0].items;
        for (var i = end; i >= start; i--) {
          var item = items[parseInt(i.toString(), 10)];
          var container = parentEle.querySelector('#' + item.id + CONTAINER_ID);
          var ele_6 = container.querySelector('#' + item.id);
          item.setProperties({
            size: exports.RibbonItemSize.Large
          }, true);
          _this.setItemSize(ele_6, item);
          parentEle.insertAdjacentElement('afterend', container);
        }
        if (!shouldSkip || shouldClear) {
          sf.base.remove(parentEle);
        }
      };
      var expandCollectionsToLarge = function expandCollectionsToLarge(start, end, parentEle) {
        var collections = _this.tabs[parseInt(_this.selectedTab.toString(), 10)].groups[parseInt(groupIndex.toString(), 10)].collections;
        for (var i = end; i >= start; i--) {
          var collection = collections[parseInt(i.toString(), 10)];
          var collectionEle = parentEle.querySelector('#' + collection.id);
          var ele_7 = collectionEle.querySelector('#' + collection.items[0].id);
          collection.items[0].setProperties({
            size: exports.RibbonItemSize.Large
          }, true);
          _this.setItemSize(ele_7, collection.items[0]);
          parentEle.insertAdjacentElement('afterend', collectionEle);
        }
        if (!shouldSkip || shouldClear) {
          sf.base.remove(parentEle);
        }
      };
      for (var k = 0; k < shrinkColumns.length; k++) {
        var shrinkColumn = shrinkColumns[parseInt(k.toString(), 10)];
        var valString = shrinkColumn.getAttribute('data-large-width');
        var value = valString ? parseInt(valString, 10) : null;
        if (value && (shouldSkip || tabContent.offsetWidth > value)) {
          var start = parseInt(shrinkColumn.getAttribute('data-start'), 10);
          var end = parseInt(shrinkColumn.getAttribute('data-end'), 10);
          if (orientation === exports.ItemOrientation.Row) {
            expandItemsToLarge(start, end, shrinkColumn);
          } else {
            expandCollectionsToLarge(start, end, shrinkColumn);
          }
          if (!shouldSkip || shouldClear) {
            shrinkColumn.removeAttribute('data-large-width');
          }
        } else if (value) {
          return true;
        }
      }
      return false;
    };
    Ribbon.prototype.setItemSize = function (itemEle, item) {
      if (item.type === exports.RibbonItemType.Button) {
        this.ribbonButtonModule.updateButtonSize(itemEle, item);
      } else if (item.type === exports.RibbonItemType.DropDown) {
        this.ribbonDropDownModule.updateDropDownSize(itemEle, item);
      }
      var itemContainer = itemEle.closest('.' + RIBBON_ITEM);
      itemContainer.classList.remove(RIBBON_CONTENT_HEIGHT, RIBBON_LARGE_ITEM, RIBBON_MEDIUM_ITEM, RIBBON_SMALL_ITEM);
      if (item.size === 'Large') {
        itemContainer.classList.add(RIBBON_LARGE_ITEM, RIBBON_CONTENT_HEIGHT);
      } else {
        itemContainer.classList.add(item.size === 'Medium' ? RIBBON_MEDIUM_ITEM : RIBBON_SMALL_ITEM);
      }
    };
    Ribbon.prototype.createOverflowDropdown = function (tabContent, activeContent) {
      var collapseOrder = this.getGroupResizeOrder(true);
      if (collapseOrder.length === 0) {
        return;
      }
      var _loop_1 = function _loop_1(i) {
        var group = collapseOrder[parseInt(i.toString(), 10)];
        var groupEle = this_1.tabObj.element.querySelector('#' + group.id);
        groupEle.setAttribute('data-expanded-width', activeContent.offsetWidth.toString());
        var groupContainer = groupEle.querySelector('#' + group.id + CONTAINER_ID);
        var groupOverFlow = this_1.createElement('div', {
          className: RIBBON_GROUP_OVERFLOW + SPACE + RIBBON_LARGE_ITEM,
          id: group.id + OVERFLOW_ID + CONTAINER_ID
        });
        groupEle.insertBefore(groupOverFlow, groupContainer);
        var groupIndex = getIndex(this_1.tabs[this_1.selectedTab].groups, function (e) {
          return e.id === group.id;
        });
        var tab = this_1.tabs[this_1.selectedTab];
        //Expanding the items in the group to their original expanded state
        this_1.checkSmallToMedium(tab, groupIndex, tabContent, activeContent, true, false);
        this_1.checkMediumToLarge(tab, groupIndex, tabContent, activeContent, true, false);
        this_1.ribbonDropDownModule.createOverFlowDropDown(group.id, group.header, group.groupIconCss, groupContainer, groupOverFlow);
        this_1.tabs[parseInt(this_1.selectedTab.toString(), 10)].groups[parseInt(groupIndex.toString(), 10)].setProperties({
          isCollapsed: true
        }, true);
      };
      var this_1 = this;
      for (var i = 0; i < collapseOrder.length && tabContent.offsetWidth < activeContent.offsetWidth; i++) {
        _loop_1(i);
      }
    };
    Ribbon.prototype.removeOverflowDropdown = function (tabContent, activeContent, isClear) {
      if (isClear === void 0) {
        isClear = false;
      }
      var expandOrder = this.getGroupResizeOrder(false);
      if (expandOrder.length === 0) {
        return false;
      }
      var _loop_2 = function _loop_2(i) {
        var group = expandOrder[parseInt(i.toString(), 10)];
        var groupEle = this_2.tabObj.element.querySelector('#' + group.id);
        if (!groupEle) {
          return "break";
        } //to handle the rerendering of tabcontrol when a ribbon tab is added/removed
        var width = parseInt(groupEle.getAttribute('data-expanded-width'), 10);
        if (!isClear && tabContent.offsetWidth < width) {
          return {
            value: true
          };
        }
        this_2.removeDropdown(group.id);
        var groupIndex = getIndex(this_2.tabs[this_2.selectedTab].groups, function (e) {
          return e.id === group.id;
        });
        this_2.tabs[parseInt(this_2.selectedTab.toString(), 10)].groups[parseInt(groupIndex.toString(), 10)].setProperties({
          isCollapsed: false
        }, true);
        var tab = this_2.tabs[this_2.selectedTab];
        //Shrinking the items in the group to their previous shrinked state (before moving to dropdown)
        this_2.checkLargeToMedium(tab, groupIndex, tabContent, activeContent, true);
        this_2.checkMediumToSmall(tab, groupIndex, tabContent, activeContent, true);
      };
      var this_2 = this;
      for (var i = 0; i < expandOrder.length; i++) {
        var state_1 = _loop_2(i);
        if (_typeof(state_1) === "object") return state_1.value;
        if (state_1 === "break") break;
      }
      return false;
    };
    Ribbon.prototype.removeDropdown = function (groupId) {
      var dropdownElement = this.tabObj.element.querySelector('#' + groupId + OVERFLOW_ID + DROPDOWN_ID);
      if (dropdownElement) {
        var groupOverFlow = dropdownElement.parentElement;
        this.ribbonDropDownModule.removeOverFlowDropDown(dropdownElement);
        sf.base.remove(groupOverFlow);
      }
    };
    Ribbon.prototype.getGroupResizeOrder = function (isCollapse) {
      var groups = this.tabs[this.selectedTab].groups;
      if (this.activeLayout === 'Classic') {
        groups = groups.filter(function (e) {
          // (isUndefined(e.isCollapsible) || e.isCollapsible) => check whethe rhte item is collapsible
          // if a isCollapsed property is undefined, then it is considered collapsible and included in collapsible list
          // ((isCollapse && !e.isCollapsed)||(!isCollapse && e.isCollapsed)) => isCollapse !== e.isCollapsed
          return (sf.base.isUndefined(e.isCollapsible) || e.isCollapsible) && (isCollapse && sf.base.isUndefined(e.isCollapsed) || !sf.base.isUndefined(e.isCollapsed) && isCollapse !== e.isCollapsed);
        });
      }
      //sort the collapsible groups based on the priority
      groups.sort(function (a, b) {
        return a.priority - b.priority;
      });
      //reverse the sorted array to return the array in descending order while collapsing.
      return isCollapse ? groups.reverse() : groups;
    };
    Ribbon.prototype.destroyScroll = function () {
      if (this.scrollModule) {
        this.scrollModule.destroy();
        this.scrollModule = null;
      }
    };
    Ribbon.prototype.clearOverflowDropDown = function (index) {
      var activeContent = this.tabObj.element.querySelector('#' + this.tabs[parseInt(index.toString(), 10)].id + CONTENT_ID);
      if (!activeContent) {
        return;
      }
      var tabContent = activeContent.closest('.' + TAB_CONTENT);
      if (this.activeLayout === 'Simplified') {
        this.removeSimplfiedOverflow(activeContent, tabContent, index, true);
      } else {
        this.removeOverflowDropdown(activeContent, tabContent, true);
      }
    };
    Ribbon.prototype.ribbonTabSelecting = function (e) {
      var _this = this;
      var eventArgs = {
        cancel: e.cancel,
        isInteracted: e.isInteracted,
        previousIndex: e.previousIndex,
        selectedIndex: e.selectedIndex
      };
      this.trigger('tabSelecting', eventArgs, function (args) {
        if (args.cancel) {
          return;
        }
        _this.destroyScroll();
        if (!_this.isAddRemove) {
          _this.clearOverflowDropDown(e.selectedIndex);
        }
        var selectedTabContent = _this.tabObj.items[e.selectingIndex].content;
        if (!selectedTabContent.querySelector('.' + RIBBON_GROUP) && _this.tabs[e.selectingIndex].groups.length !== 0) {
          var elements = _this.createGroups(_this.tabs[e.selectingIndex].groups, e.selectingIndex);
          sf.base.append(elements, selectedTabContent);
        }
        if (_this.activeLayout === 'Simplified' && e.selectingIndex === _this.selectedTab) {
          var overflowTarget = _this.overflowDDB.target;
          var tabContainer = overflowTarget.querySelector('#' + _this.tabs[e.selectingIndex].id + OVERFLOW_ID);
          tabContainer.classList.add(RIBBON_TAB_ACTIVE);
        }
      });
    };
    Ribbon.prototype.createTabItems = function (tabs) {
      var _this = this;
      var tabItems = [];
      for (var i = 0; i < tabs.length; i++) {
        var ribbonTab = tabs[parseInt(i.toString(), 10)];
        var header = this.createElement('span', {
          innerHTML: ribbonTab.header,
          id: ribbonTab.id + HEADER_ID
        });
        header.onclick = function () {
          _this.minimize(false);
        };
        header.ondblclick = function () {
          _this.minimize(true);
        };
        var tab = {
          header: {
            text: header
          },
          id: ribbonTab.id,
          cssClass: ribbonTab.cssClass
        };
        var content = this.createElement('div', {
          className: tab.cssClass,
          id: ribbonTab.id + CONTENT_ID
        });
        content.classList.add(RIBBON_TAB_ITEM);
        tab.content = content;
        tabItems.push(tab);
      }
      return tabItems;
    };
    Ribbon.prototype.renderInitialTab = function (index) {
      var elements = this.createGroups(this.tabs[parseInt(index.toString(), 10)].groups, index);
      var content = this.tabObj.items[parseInt(index.toString(), 10)].content;
      sf.base.append(elements, content);
      if (this.activeLayout === 'Simplified') {
        this.element.classList.add(RIBBON_SIMPLIFIED_MODE);
      }
      this.checkOverflow();
    };
    Ribbon.prototype.addOverflowButton = function (btnId) {
      var overflowButton = this.createElement('button', {
        id: btnId
      });
      var overflowTarget = this.createElement('div', {
        className: RIBBON_OVERFLOW_TARGET
      });
      var overflowDDB = new sf.splitbuttons.DropDownButton({
        iconCss: OVERFLOW_ICON,
        cssClass: DROPDOWNBUTTON_HIDE + SPACE + RIBBON_GROUP_OVERFLOW_DDB,
        target: overflowTarget
      }, overflowButton);
      this.element.classList.add(RIBBON_OVERFLOW);
      return overflowDDB;
    };
    Ribbon.prototype.removeOverflowButton = function (overflowDDB) {
      if (overflowDDB) {
        var btnEle = overflowDDB.element;
        overflowDDB.destroy();
        btnEle.remove();
      }
    };
    Ribbon.prototype.createGroupContainer = function (groupId, groupHeader) {
      var ofGroupContainer = this.createElement('div', {
        className: RIBBON_OF_GROUP_CONTAINER,
        id: groupId + CONTAINER_ID
      });
      var ofGroupHeader = this.createElement('div', {
        className: RIBBON_OVERFLOW_HEADER,
        id: groupId + HEADER_ID,
        innerHTML: groupHeader
      });
      ofGroupContainer.append(ofGroupHeader);
      return ofGroupContainer;
    };
    Ribbon.prototype.addExpandCollapse = function () {
      var _this = this;
      this.collapseButton = this.createElement('span', {
        className: RIBBON_COLLAPSE_BUTTON + SPACE + EXPAND_COLLAPSE_ICON,
        id: this.tabObj.element.id + COLLAPSE_BUTTON_ID,
        attrs: {
          'tabindex': '0',
          'type': 'button',
          'aria-label': 'Layout Switcher'
        }
      });
      this.collapseButton.onclick = function () {
        _this.toggleLayout();
      };
      this.element.classList.add(RIBBON_COLLAPSIBLE);
      if (this.activeLayout === 'Simplified') {
        this.collapseButton.classList.add(RIBBON_EXPAND_BUTTON);
      }
      this.tabObj.element.appendChild(this.collapseButton);
    };
    Ribbon.prototype.removeExpandCollapse = function () {
      var _this = this;
      var index = getIndex(this.tooltipData, function (e) {
        return e.id === _this.collapseButton.id;
      });
      if (index !== -1) {
        this.tooltipData.splice(index, 1);
      }
      this.element.classList.remove(RIBBON_COLLAPSIBLE);
      sf.base.remove(this.tabObj.element.querySelector('.' + RIBBON_COLLAPSE_BUTTON));
      this.collapseButton = null;
    };
    Ribbon.prototype.reRenderTabs = function () {
      this.destroyScroll();
      this.destroyTabItems(this.tabsInternal);
      this.tabsInternal = this.tabs.slice();
      this.checkID(this.tabs, 'tab', this.element.id);
      var tabItems = this.createTabItems(this.tabs);
      this.tabObj.setProperties({
        items: tabItems
      });
      this.renderInitialTab(this.tabObj.selectedItem);
    };
    Ribbon.prototype.switchLayout = function () {
      for (var i = 0; i <= this.tabs.length - 1; i++) {
        var tabIndex = i;
        var contentEle = this.tabObj.items[parseInt(tabIndex.toString(), 10)].content;
        if (contentEle.innerHTML !== '') {
          var tab = this.tabs[parseInt(tabIndex.toString(), 10)];
          var groupList = this.tabs[parseInt(tabIndex.toString(), 10)].groups;
          var activeContent = this.tabObj.element.querySelector('#' + this.tabs[parseInt(tabIndex.toString(), 10)].id + CONTENT_ID);
          var tabContent = activeContent.closest('.' + TAB_CONTENT);
          if (this.activeLayout === 'Simplified') {
            this.element.classList.add(RIBBON_OVERFLOW);
            for (var i_1 = 0; i_1 < groupList.length; i_1++) {
              var group = groupList[parseInt(i_1.toString(), 10)];
              if (group.isCollapsed) {
                this.removeDropdown(group.id);
              } else {
                this.checkSmallToMedium(tab, i_1, tabContent, activeContent, true, false);
                this.checkMediumToLarge(tab, i_1, tabContent, activeContent, true, false);
              }
              var groupContainer = tabContent.querySelector('#' + group.id + CONTAINER_ID);
              var shrinkColumns = groupContainer.querySelector('.e-ribbon-shrink');
              if (shrinkColumns) {
                shrinkColumns.remove();
              }
              var groupHeader = groupContainer.querySelector('#' + group.id + HEADER_ID);
              groupHeader.remove();
              var groupContent = groupContainer.querySelector('#' + group.id + CONTENT_ID);
              groupContent.classList.replace(RIBBON_ROW, RIBBON_COLUMN);
              groupContent.classList.remove(RIBBON_CONTENT_HEIGHT);
              for (var j = 0; j < group.collections.length; j++) {
                var collection = group.collections[parseInt(j.toString(), 10)];
                var groupCollection = groupContainer.querySelector('#' + collection.id);
                groupCollection.classList.replace(RIBBON_ROW, RIBBON_COLUMN);
                for (var k = 0; k < collection.items.length; k++) {
                  var itemList = collection.items;
                  var item = collection.items[parseInt(k.toString(), 10)];
                  var flag = true;
                  while (flag && item.simplifiedMode === 'None') {
                    k++;
                    var itemEle_1 = tabContent.querySelector('#' + item.id + CONTAINER_ID);
                    itemEle_1.remove();
                    if (k < itemList.length) {
                      item = itemList[parseInt(k.toString(), 10)];
                    } else {
                      flag = false;
                    }
                  }
                  if (!flag) {
                    break;
                  }
                  var itemEle = tabContent.querySelector('#' + item.id + CONTAINER_ID);
                  var ele = groupContainer.querySelector('#' + item.id);
                  if (item.size === 'Large' && item.type !== 'ColorPicker') {
                    item.setProperties({
                      size: exports.RibbonItemSize.Medium
                    }, true);
                    this.setItemSize(ele, item);
                  }
                  if (item.simplifiedMode === 'Popup') {
                    this.createOverflowPopup(tabIndex, group.enableGroupOverflow, group.id, group.header, itemEle, groupContainer);
                  }
                }
              }
            }
          } else {
            this.element.classList.remove(RIBBON_OVERFLOW);
            for (var i_2 = 0; i_2 < groupList.length; i_2++) {
              var group = groupList[parseInt(i_2.toString(), 10)];
              var alignType = groupList[parseInt(i_2.toString(), 10)].orientation;
              var groupContainer = tabContent.querySelector('#' + group.id + CONTAINER_ID);
              var groupContent = groupContainer.querySelector('#' + group.id + CONTENT_ID);
              var groupHeader = this.createElement('div', {
                className: RIBBON_GROUP_HEADER,
                id: group.id + HEADER_ID,
                innerHTML: group.header
              });
              groupContainer.appendChild(groupHeader);
              if (alignType === 'Row') {
                groupContent.classList.replace(RIBBON_COLUMN, RIBBON_ROW);
              }
              groupContent.classList.add(RIBBON_CONTENT_HEIGHT);
              for (var j = 0; j < group.collections.length; j++) {
                var overflowDDB = void 0;
                var overflowtarget = void 0;
                if (!group.enableGroupOverflow) {
                  overflowDDB = this.overflowDDB;
                  if (overflowDDB) {
                    overflowtarget = this.overflowDDB.target;
                  }
                } else {
                  var overflowDDBEle = groupContainer.querySelector('#' + group.id + GROUPOF_BUTTON_ID);
                  if (overflowDDBEle) {
                    overflowDDB = sf.base.getInstance(overflowDDBEle, sf.splitbuttons.DropDownButton);
                    overflowtarget = overflowDDB.target;
                  }
                }
                var collection = group.collections[parseInt(j.toString(), 10)];
                var groupCollection = groupContainer.querySelector('#' + collection.id);
                if (alignType === 'Column') {
                  groupCollection.classList.replace(RIBBON_COLUMN, RIBBON_ROW);
                }
                for (var k = 0; k < collection.items.length; k++) {
                  var item = collection.items[parseInt(k.toString(), 10)];
                  if (item.simplifiedMode === 'None') {
                    var itemEle = this.createItems([item], alignType, group.id, group.header, group.enableGroupOverflow, tabIndex)[0];
                    groupCollection.append(itemEle);
                  } else if (item.simplifiedMode === 'Popup') {
                    var itemEle = overflowtarget.querySelector('#' + item.id + CONTAINER_ID);
                    groupCollection.append(itemEle);
                  } else if (item.simplifiedMode === 'Group') {
                    //To make sure the items are in proper order
                    var itemEle = groupContainer.querySelector('#' + item.id + CONTAINER_ID);
                    groupCollection.append(itemEle);
                  } else {
                    var itemEle = groupContainer.querySelector('#' + item.id + CONTAINER_ID);
                    if (!itemEle) {
                      itemEle = overflowtarget.querySelector('#' + item.id + CONTAINER_ID);
                    }
                    groupCollection.append(itemEle);
                  }
                  var ele = groupContainer.querySelector('#' + item.id);
                  if (item.allowedSizes === 'Large' || item.allowedSizes === 'LargeMedium' || item.allowedSizes === 'All') {
                    item.setProperties({
                      size: exports.RibbonItemSize.Large
                    }, true);
                    this.setItemSize(ele, item);
                  } else if (item.size === 'Small' && item.allowedSizes === 'Medium' || item.allowedSizes === 'MediumSmall') {
                    item.setProperties({
                      size: exports.RibbonItemSize.Medium
                    }, true);
                    this.setItemSize(ele, item);
                  }
                }
                if (group.enableGroupOverflow && overflowDDB) {
                  if (overflowtarget.childElementCount === 0) {
                    this.removeOverflowButton(overflowDDB);
                  }
                }
              }
            }
          }
          this.checkOverflow();
        }
      }
      if (this.activeLayout === 'Classic') {
        this.removeOverflowButton(this.overflowDDB);
        this.overflowDDB = null;
      }
    };
    Ribbon.prototype.launcherIconClicked = function (id) {
      var eventArgs = {
        groupId: id
      };
      this.trigger('launcherIconClick', eventArgs);
    };
    Ribbon.prototype.createGroups = function (groupList, tabIndex) {
      var groupElements = [];
      for (var i = 0; i < groupList.length; i++) {
        var group = groupList[parseInt(i.toString(), 10)];
        var alignType = group.orientation;
        var groupEle = this.createElement('div', {
          className: group.cssClass,
          id: group.id
        });
        groupEle.classList.add(RIBBON_GROUP);
        groupElements.push(groupEle);
        var groupContainer = this.createElement('div', {
          className: group.cssClass,
          id: group.id + CONTAINER_ID
        });
        groupContainer.classList.add(RIBBON_GROUP_CONTAINER);
        groupEle.appendChild(groupContainer);
        var groupContent = this.createElement('div', {
          className: this.activeLayout === 'Simplified' ? RIBBON_GROUP_CONTENT : RIBBON_GROUP_CONTENT + SPACE + RIBBON_CONTENT_HEIGHT,
          id: group.id + CONTENT_ID
        });
        groupContent.classList.add(alignType === 'Column' || this.activeLayout === 'Simplified' ? RIBBON_COLUMN : RIBBON_ROW);
        groupContainer.appendChild(groupContent);
        if (this.activeLayout === 'Classic') {
          var groupHeader = this.createElement('div', {
            className: RIBBON_GROUP_HEADER,
            id: group.id + HEADER_ID,
            innerHTML: group.header
          });
          groupContainer.appendChild(groupHeader);
        }
        if (group.showLauncherIcon) {
          var launcherIcon = this.createElement('div', {
            className: RIBBON_LAUNCHER_ICON_ELE + ' ' + (this.launcherIconCss ? this.launcherIconCss : RIBBON_LAUNCHER_ICON),
            id: group.id + LAUNCHER_ID
          });
          groupContainer.appendChild(launcherIcon);
          groupContainer.classList.add(RIBBON_LAUNCHER);
          sf.base.EventHandler.add(launcherIcon, 'click', this.launcherIconClicked.bind(this, group.id), this);
        }
        var elements = this.createCollection(group.collections, group.orientation, group.id, group.header, group.enableGroupOverflow, tabIndex, groupContainer);
        sf.base.append(elements, groupContent);
      }
      return groupElements;
    };
    Ribbon.prototype.validateItemSize = function () {
      for (var k = 0; k < this.tabs.length; k++) {
        var groupList = this.tabs[parseInt(k.toString(), 10)].groups;
        for (var l = 0; l < groupList.length; l++) {
          var collectionList = groupList[parseInt(l.toString(), 10)].collections;
          var alignType = groupList[parseInt(l.toString(), 10)].orientation;
          for (var i = 0; i < collectionList.length; i++) {
            var items = collectionList[parseInt(i.toString(), 10)].items;
            for (var j = 0; j < items.length; j++) {
              var ribbonitem = items[parseInt(j.toString(), 10)];
              if (ribbonitem.type === 'ColorPicker' && (ribbonitem.size !== 'Small' || ribbonitem.allowedSizes !== 'Small')) {
                ribbonitem.setProperties({
                  size: 'Small',
                  allowedSizes: 'Small'
                }, true);
              } else if ((ribbonitem.type === 'ComboBox' || ribbonitem.type === 'CheckBox') && (ribbonitem.size !== 'Medium' || ribbonitem.allowedSizes !== 'Medium')) {
                ribbonitem.setProperties({
                  size: 'Medium',
                  allowedSizes: 'Medium'
                }, true);
              } else if (alignType === 'Column' && items.length > 1 || alignType === 'Row' && collectionList.length > 1) {
                if (ribbonitem.size === 'Large') {
                  ribbonitem.setProperties({
                    size: exports.RibbonItemSize.Medium
                  }, true);
                }
                if (ribbonitem.allowedSizes === 'All') {
                  ribbonitem.setProperties({
                    allowedSizes: 'MediumSmall'
                  }, true);
                } else if (ribbonitem.allowedSizes === 'LargeMedium' || ribbonitem.allowedSizes === 'Large') {
                  ribbonitem.setProperties({
                    allowedSizes: 'Medium'
                  }, true);
                }
              }
            }
          }
        }
      }
    };
    Ribbon.prototype.createCollection = function (collectionList, alignType, groupId, groupHeader, isGroupOF, tabIndex, groupContainer) {
      var collectionElements = [];
      for (var i = 0; i < collectionList.length; i++) {
        var collection = collectionList[parseInt(i.toString(), 10)];
        var collectionEle = this.createElement('div', {
          className: collection.cssClass,
          id: collection.id
        });
        collectionEle.classList.add(RIBBON_COLLECTION);
        collectionEle.classList.add(alignType !== 'Column' || this.activeLayout === 'Simplified' ? RIBBON_COLUMN : RIBBON_ROW);
        collectionElements.push(collectionEle);
        var elements = this.createItems(collection.items, alignType, groupId, groupHeader, isGroupOF, tabIndex, groupContainer);
        sf.base.append(elements, collectionEle);
        if (alignType === 'Row' && i === 2) {
          break;
        }
      }
      return collectionElements;
    };
    Ribbon.prototype.createItems = function (itemList, alignType, groupId, groupHeader, isGroupOF, tabIndex, groupContainer) {
      var itemElements = [];
      for (var i = 0; i < itemList.length; i++) {
        var item = itemList[parseInt(i.toString(), 10)];
        //To stop rendering of items with simplified mode position type as none
        var flag = true;
        while (this.activeLayout === 'Simplified' && flag && item.simplifiedMode === 'None') {
          i++;
          if (i < itemList.length) {
            item = itemList[parseInt(i.toString(), 10)];
          } else {
            flag = false;
          }
        }
        if (!flag) {
          break;
        }
        var itemEle = this.createElement('div', {
          className: item.cssClass,
          id: item.id + CONTAINER_ID
        });
        itemEle.classList.add(RIBBON_ITEM);
        // To avoid undefined items condition is added
        if (item.ribbonTooltipSettings && isTooltipPresent(item.ribbonTooltipSettings)) {
          itemEle.classList.add(RIBBON_TOOLTIP_TARGET);
          this.tooltipData.push({
            id: itemEle.id,
            data: item.ribbonTooltipSettings
          });
        }
        if (this.activeLayout === 'Simplified') {
          if (item.size === 'Large' && item.type !== 'ColorPicker') {
            item.setProperties({
              size: exports.RibbonItemSize.Medium
            }, true);
            itemEle.classList.add(RIBBON_MEDIUM_ITEM);
          }
        } else {
          if (item.size === 'Large' && ['CheckBox', 'ComboBox', 'ColorPicker'].indexOf(item.type) === -1) {
            itemEle.classList.add(RIBBON_LARGE_ITEM, RIBBON_CONTENT_HEIGHT);
          }
        }
        if (item.size === 'Small' || item.type === 'ColorPicker') {
          itemEle.classList.add(RIBBON_SMALL_ITEM);
        } else {
          itemEle.classList.add(RIBBON_MEDIUM_ITEM);
        }
        if (this.activeLayout === 'Simplified' && item.simplifiedMode === 'Popup') {
          this.createOverflowPopup(tabIndex, isGroupOF, groupId, groupHeader, itemEle, groupContainer);
        } else {
          // For normal mode and Simplified mode position type as Group and Auto
          itemElements.push(itemEle);
        }
        switch (item.type) {
          case 'Button':
            this.ribbonButtonModule.createButton(item, itemEle);
            break;
          case 'DropDown':
            this.ribbonDropDownModule.createDropDown(item, itemEle);
            break;
          case 'CheckBox':
            this.ribbonCheckBoxModule.createCheckBox(item, itemEle);
            break;
          case 'ColorPicker':
            this.ribbonColorPickerModule.createColorPicker(item, itemEle);
            break;
          case 'ComboBox':
            this.ribbonComboBoxModule.createComboBox(item, itemEle);
            break;
          case 'Template':
            this.createTemplateContent(item, itemEle);
            break;
        }
        if (alignType === 'Column' && i === 2) {
          break;
        }
      }
      return itemElements;
    };
    Ribbon.prototype.createHelpPaneTemplate = function () {
      if (this.helpPaneTemplate) {
        var ribbonEle = this.getTemplateContent(this.helpPaneTemplate);
        this.ribbonTempEle = this.createElement('div', {
          className: RIBBON_RIGHT_TEMPLATE,
          id: this.element.id + RIBBON_RIGHT_PANE_TEMPLATE_ID,
          innerHTML: ribbonEle
        });
        var tabEle = this.tabObj.element;
        var toolbarEle = tabEle.querySelector('.e-toolbar');
        toolbarEle.after(this.ribbonTempEle);
        tabEle.style.setProperty(RIBBON_RIGHT_PANE_TEMPLATE_WIDTH, this.ribbonTempEle.offsetWidth + 'px');
      }
    };
    Ribbon.prototype.createTemplateContent = function (item, itemElement) {
      var ele = this.getTemplateContent(item.ItemTemplate);
      var itemEle = this.createElement('div', {
        className: item.disabled ? DISABLED_CSS + SPACE + item.cssClass : item.cssClass,
        id: item.id,
        innerHTML: ele
      });
      if (item.disabled) {
        itemEle.setAttribute('disabled', '');
      }
      itemElement.appendChild(itemEle);
    };
    Ribbon.prototype.getTemplateContent = function (template) {
      var content = '';
      if (typeof template === 'string') {
        try {
          var tempEle = sf.base.select(template);
          if (tempEle) {
            //Return innerHTML incase of jsrenderer script else outerHTML
            content = tempEle.tagName === 'SCRIPT' ? tempEle.innerHTML : tempEle.outerHTML;
          } else {
            content = template;
          }
        } catch (e) {
          content = template;
        }
      } else {
        content = template.outerHTML;
      }
      return content;
    };
    Ribbon.prototype.checkID = function (list, type, initId) {
      var key = type === 'tab' ? TAB_ID : type === 'group' ? GROUP_ID : type === 'collection' ? COLLECTION_ID : ITEM_ID;
      for (var i = 0; i < list.length; i++) {
        var listitem = list[parseInt(i.toString(), 10)];
        if (!listitem.id) {
          listitem.setProperties({
            id: initId + key + this.idIndex++
          }, true);
        }
        switch (type) {
          case 'tab':
            listitem.setProperties({
              groups: this.checkID(listitem.groups, 'group', listitem.id)
            }, true);
            break;
          case 'group':
            listitem.setProperties({
              collections: this.checkID(listitem.collections, 'collection', listitem.id)
            }, true);
            break;
          case 'collection':
            listitem.setProperties({
              items: this.checkID(listitem.items, 'item', listitem.id)
            }, true);
            break;
          default:
            break;
        }
      }
      return list;
    };
    Ribbon.prototype.updateCommonProperty = function (commonProp) {
      for (var i = 0; i < this.tabs.length; i++) {
        var tab = this.tabs[parseInt(i.toString(), 10)];
        for (var j = 0; j < tab.groups.length; j++) {
          var group = tab.groups[parseInt(j.toString(), 10)];
          var contentEle = this.tabObj.items[parseInt(i.toString(), 10)].content;
          var dropdownElement = group.isCollapsed ? contentEle.querySelector('#' + group.id + OVERFLOW_ID + DROPDOWN_ID) : null;
          for (var k = 0; k < group.collections.length; k++) {
            var collection = group.collections[parseInt(k.toString(), 10)];
            for (var l = 0; l < collection.items.length; l++) {
              var item = collection.items[parseInt(l.toString(), 10)];
              var ele = dropdownElement ? this.ribbonDropDownModule.getDDBItemElement(dropdownElement, item.id) : contentEle.querySelector('#' + item.id);
              if (ele) {
                var moduleName = this.getItemModuleName(item);
                if (moduleName !== 'template') {
                  updateCommonProperty(ele, moduleName, commonProp);
                } else if (!sf.base.isNullOrUndefined(commonProp.enableRtl)) {
                  ele.classList[commonProp.enableRtl ? 'add' : 'remove'](RTL_CSS);
                }
              }
            }
          }
        }
      }
    };
    Ribbon.prototype.removeLauncherIcon = function (groupId, dropdownElement, contentEle) {
      var containerId = groupId + CONTAINER_ID;
      var containerEle = dropdownElement ? this.ribbonDropDownModule.getDDBItemElement(dropdownElement, containerId) : contentEle.querySelector('#' + containerId);
      if (containerEle) {
        containerEle.classList.remove(RIBBON_LAUNCHER);
        var launcherIcon = containerEle.querySelector('#' + groupId + LAUNCHER_ID);
        sf.base.remove(launcherIcon);
      }
    };
    Ribbon.prototype.destroyTabItems = function (tabs) {
      for (var i = 0; i < tabs.length; i++) {
        var tab = tabs[parseInt(i.toString(), 10)];
        for (var j = 0; j < tab.groups.length; j++) {
          var group = tab.groups[parseInt(j.toString(), 10)];
          var contentEle = this.tabObj.items[parseInt(i.toString(), 10)].content;
          var dropdownElement = group.isCollapsed ? contentEle.querySelector('#' + group.id + OVERFLOW_ID + DROPDOWN_ID) : null;
          if (group.showLauncherIcon) {
            this.removeLauncherIcon(group.id, dropdownElement, contentEle);
          }
          for (var k = 0; k < group.collections.length; k++) {
            var collection = group.collections[parseInt(k.toString(), 10)];
            for (var l = 0; l < collection.items.length; l++) {
              var item = collection.items[parseInt(l.toString(), 10)];
              var ele = dropdownElement ? this.ribbonDropDownModule.getDDBItemElement(dropdownElement, item.id) : contentEle.querySelector('#' + item.id);
              if (ele) {
                this.destroyFunction(item, ele);
              }
            }
          }
          if (dropdownElement) {
            this.ribbonDropDownModule.removeOverFlowDropDown(dropdownElement);
          }
        }
      }
    };
    Ribbon.prototype.destroyFunction = function (item, ele) {
      var moduleName = this.getItemModuleName(item);
      if (moduleName !== 'template') {
        destroyControl(ele, moduleName);
      }
      if (item.ribbonTooltipSettings) {
        var index = getIndex(this.tooltipData, function (e) {
          return e.id === item.id + CONTAINER_ID;
        });
        if (index !== -1) {
          this.tooltipData.splice(index, 1);
        }
      }
    };
    Ribbon.prototype.getItemModuleName = function (item) {
      switch (item.type) {
        case 'Button':
          return 'btn';
        case 'DropDown':
          return item.dropDownSettings.isDropDownButton ? 'dropdown-btn' : 'split-btn';
        case 'CheckBox':
          return 'checkbox';
        case 'ColorPicker':
          return 'colorpicker';
        case 'ComboBox':
          return 'combobox';
        default:
          return 'template';
      }
    };
    Ribbon.prototype.clearOverflowResize = function () {
      this.destroyScroll();
      this.clearOverflowDropDown(this.selectedTab);
      var tab = this.tabs[this.selectedTab];
      var activeContent = this.tabObj.element.querySelector('#' + this.tabs[this.selectedTab].id + CONTENT_ID);
      var tabContent = activeContent.closest('.' + TAB_CONTENT);
      for (var j = 0; j < tab.groups.length; j++) {
        this.checkSmallToMedium(tab, j, tabContent, activeContent, true, true);
        this.checkMediumToLarge(tab, j, tabContent, activeContent, true, true);
      }
    };
    /**
     * Refreshes the layout.
     *
     * @returns {void}
     */
    Ribbon.prototype.refreshLayout = function () {
      this.resizeHandler();
    };
    /**
     * Selects the tab
     *
     * @param  {string} tabId - Gets the tab ID
     * @returns {void}
     */
    Ribbon.prototype.selectTab = function (tabId) {
      var index = getIndex(this.tabs, function (e) {
        return e.id === tabId;
      });
      this.setProperties({
        selectedTab: index
      });
    };
    /**
     * Adds the ribbon tab.
     *
     * @param {RibbonTabModel} tab - Gets the ribbon tab model
     * @param {string} targetId  - Gets the ID of the target tab to add the new tab.
     * @param {boolean} isAfter - Defines whether the tab is added before or after the target.
     * @returns {void}
     */
    Ribbon.prototype.addTab = function (tab, targetId, isAfter) {
      if (isAfter === void 0) {
        isAfter = false;
      }
      var index;
      if (targetId) {
        index = getIndex(this.tabs, function (e) {
          return e.id === targetId;
        });
        index = index < 0 ? this.tabs.length : isAfter ? index + 1 : index;
      } else {
        index = this.tabs.length;
      }
      this.tabsInternal = this.tabs.slice();
      this.tabsInternal.splice(index, 0, tab);
      this.setProperties({
        tabs: this.tabsInternal
      }, true);
      this.tabsInternal = this.tabs.slice();
      this.checkID([this.tabs[parseInt(index.toString(), 10)]], 'tab', this.element.id);
      var tabItem = this.createTabItems([tab]);
      this.tabObj.addTab(tabItem, index);
    };
    /**
     * Removes the ribbon tab.
     *
     * @param {string} tabId - Gets the tab ID
     * @returns {void}
     */
    Ribbon.prototype.removeTab = function (tabId) {
      var index = getIndex(this.tabs, function (e) {
        return e.id === tabId;
      });
      if (index === -1) {
        return;
      }
      var contentEle = this.tabObj.items[parseInt(index.toString(), 10)].content;
      if (this.tabs[parseInt(index.toString(), 10)].groups && contentEle.innerHTML !== '') {
        for (var j = 0; j < this.tabs[parseInt(index.toString(), 10)].groups.length; j++) {
          var group = this.tabs[parseInt(index.toString(), 10)].groups[parseInt(j.toString(), 10)];
          var dropdownElement = group.isCollapsed ? contentEle.querySelector('#' + group.id + OVERFLOW_ID + DROPDOWN_ID) : null;
          for (var k = 0; k < group.collections.length; k++) {
            var collection = group.collections[parseInt(k.toString(), 10)];
            for (var l = 0; l < collection.items.length; l++) {
              var item = collection.items[parseInt(l.toString(), 10)];
              var ele = dropdownElement ? this.ribbonDropDownModule.getDDBItemElement(dropdownElement, item.id) : contentEle.querySelector('#' + item.id);
              if (ele) {
                this.destroyFunction(item, ele);
              }
            }
          }
          if (dropdownElement) {
            this.ribbonDropDownModule.removeOverFlowDropDown(dropdownElement);
          }
        }
      }
      if (index === this.selectedTab) {
        this.isAddRemove = true;
      }
      this.tabsInternal = this.tabs.slice();
      this.tabsInternal.splice(index, 1);
      this.setProperties({
        tabs: this.tabsInternal
      }, true);
      this.tabObj.removeTab(index);
    };
    /**
     * Adds the ribbon group.
     *
     * @param {string} tabId - Gets the tab ID.
     * @param {RibbonGroupModel} group - Gets the ribbon group model.
     * @param {string} targetId - Gets the ID of the target group to add the new group.
     * @param {boolean} isAfter - Defines whether the group is added before or after the target.
     * @returns {void}
     */
    Ribbon.prototype.addGroup = function (tabId, group, targetId, isAfter) {
      if (isAfter === void 0) {
        isAfter = false;
      }
      var tabIndex = getIndex(this.tabs, function (e) {
        return e.id === tabId;
      });
      if (tabIndex === -1) {
        return;
      }
      if (this.selectedTab === tabIndex) {
        this.clearOverflowResize();
      }
      var tab = this.tabs[parseInt(tabIndex.toString(), 10)];
      var ribbonGroups = tab.groups.slice();
      var index = 0;
      if (targetId) {
        index = getIndex(ribbonGroups, function (e) {
          return e.id === targetId;
        });
        index = index < 0 ? ribbonGroups.length : isAfter ? index + 1 : index;
      } else {
        index = ribbonGroups.length;
      }
      ribbonGroups.splice(index, 0, group);
      tab.setProperties({
        groups: ribbonGroups
      }, true);
      this.checkID([tab.groups[parseInt(index.toString(), 10)]], 'group', tabId);
      //Check whether the tab items are rendered
      var contentEle = this.tabObj.items[parseInt(tabIndex.toString(), 10)].content;
      if (contentEle.innerHTML !== '') {
        var element = this.createGroups([tab.groups[parseInt(index.toString(), 10)]], tabIndex)[0];
        //insert the element in tab items property.
        var targetEle = targetId ? contentEle.querySelector('#' + targetId) : null;
        if (targetEle) {
          targetEle.insertAdjacentElement(isAfter ? 'afterend' : 'beforebegin', element);
        } else {
          contentEle.append(element);
        }
      }
      if (this.selectedTab === tabIndex) {
        this.refreshLayout();
      }
    };
    /**
     * Removes the ribbon group.
     *
     * @param {string} groupId -Gets the group ID.
     * @returns {void}
     */
    Ribbon.prototype.removeGroup = function (groupId) {
      var itemProp = getGroup(this.tabs, groupId);
      if (!itemProp) {
        return;
      }
      if (this.selectedTab === itemProp.tabIndex) {
        this.clearOverflowResize();
      }
      //Check whether the tab items are rendered
      var contentEle = this.tabObj.items[itemProp.tabIndex].content;
      if (contentEle.innerHTML !== '') {
        var dropdownElement = itemProp.group.isCollapsed ? contentEle.querySelector('#' + itemProp.group.id + OVERFLOW_ID + DROPDOWN_ID) : null;
        if (itemProp.group.showLauncherIcon) {
          this.removeLauncherIcon(itemProp.group.id, dropdownElement, contentEle);
        }
        for (var k = 0; k < itemProp.group.collections.length; k++) {
          var collection = itemProp.group.collections[parseInt(k.toString(), 10)];
          for (var l = 0; l < collection.items.length; l++) {
            var item = collection.items[parseInt(l.toString(), 10)];
            var ele = dropdownElement ? this.ribbonDropDownModule.getDDBItemElement(dropdownElement, item.id) : contentEle.querySelector('#' + item.id);
            if (ele) {
              this.destroyFunction(item, ele);
            }
          }
        }
        if (dropdownElement) {
          this.ribbonDropDownModule.removeOverFlowDropDown(dropdownElement);
        }
        contentEle.querySelector('#' + groupId).remove();
      }
      var ribbonGroups = this.tabs[itemProp.tabIndex].groups.slice();
      ribbonGroups.splice(itemProp.groupIndex, 1);
      this.tabs[itemProp.tabIndex].setProperties({
        groups: ribbonGroups
      }, true);
      if (this.selectedTab === itemProp.tabIndex) {
        this.refreshLayout();
      }
    };
    /**
     * adds the ribbon collection.
     *
     * @param {string} groupId - Gets the ribbon group ID.
     * @param {RibbonCollectionModel} collection - Gets the ribbon collection model.
     * @param {string} targetId - Gets the ID of the target collection to add the new collection.
     * @param {boolean} isAfter - Defines whether the collection is added before or after the target.
     * @returns {void}
     */
    Ribbon.prototype.addCollection = function (groupId, collection, targetId, isAfter) {
      if (isAfter === void 0) {
        isAfter = false;
      }
      var itemProp = getGroup(this.tabs, groupId);
      if (!itemProp) {
        return;
      }
      if (this.selectedTab === itemProp.tabIndex) {
        this.clearOverflowResize();
      }
      var ribbonCollections = itemProp.group.collections.slice();
      var index = 0;
      if (targetId) {
        index = getIndex(ribbonCollections, function (e) {
          return e.id === targetId;
        });
        index = index < 0 ? ribbonCollections.length : isAfter ? index + 1 : index;
      } else {
        index = ribbonCollections.length;
      }
      ribbonCollections.splice(index, 0, collection);
      itemProp.group.setProperties({
        collections: ribbonCollections
      }, true);
      this.checkID([itemProp.group.collections[parseInt(index.toString(), 10)]], 'collection', groupId);
      var contentEle = this.tabObj.items[itemProp.tabIndex].content;
      if (contentEle.innerHTML !== '') {
        var collection_1 = itemProp.group.collections[parseInt(index.toString(), 10)];
        var element = this.createCollection([collection_1], itemProp.group.orientation, itemProp.group.id, itemProp.group.header, itemProp.group.enableGroupOverflow, itemProp.tabIndex)[0];
        if (itemProp.group.isCollapsed) {
          contentEle = this.ribbonDropDownModule.getOverflowDropDownPopup(itemProp, contentEle);
        }
        //insert the element in tab items property.
        var targetEle = targetId ? contentEle.querySelector('#' + targetId) : null;
        if (targetEle) {
          targetEle.insertAdjacentElement(isAfter ? 'afterend' : 'beforebegin', element);
        } else {
          contentEle.querySelector('#' + groupId + CONTENT_ID).append(element);
        }
      }
      if (this.selectedTab === itemProp.tabIndex) {
        this.refreshLayout();
      }
    };
    /**
     * Removes the ribbon collection.
     *
     * @param {string} collectionId - Gets the collection ID.
     * @returns {void}
     */
    Ribbon.prototype.removeCollection = function (collectionId) {
      var itemProp = getCollection(this.tabs, collectionId);
      if (!itemProp) {
        return;
      }
      if (this.selectedTab === itemProp.tabIndex) {
        this.clearOverflowResize();
      }
      //Check whether the tab items are rendered
      var contentEle = this.tabObj.items[itemProp.tabIndex].content;
      if (contentEle.innerHTML !== '') {
        if (itemProp.group.isCollapsed) {
          contentEle = this.ribbonDropDownModule.getOverflowDropDownPopup(itemProp, contentEle);
        }
        var collectionEle = contentEle.querySelector('#' + collectionId);
        if (collectionEle) {
          for (var l = 0; l < itemProp.collection.items.length; l++) {
            var item = itemProp.collection.items[parseInt(l.toString(), 10)];
            var ele = contentEle.querySelector('#' + item.id);
            if (ele) {
              this.destroyFunction(item, ele);
            }
          }
          collectionEle.remove();
        }
      }
      var ribbonGroup = itemProp.group;
      var ribbonCollections = ribbonGroup.collections.slice();
      ribbonCollections.splice(itemProp.collectionIndex, 1);
      ribbonGroup.setProperties({
        collections: ribbonCollections
      }, true);
      if (this.selectedTab === itemProp.tabIndex) {
        this.refreshLayout();
      }
    };
    /**
     * Adds ribbon item.
     *
     * @param {string} collectionId - Gets the collection ID.
     * @param {RibbonItemModel} item - Gets the ribbon item model.
     * @param {string} targetId - Gets the ID of the target item to add the new item.
     * @param {boolean} isAfter - Defines whether the item is added before or after the target.
     * @returns {void}
     */
    Ribbon.prototype.addItem = function (collectionId, item, targetId, isAfter) {
      if (isAfter === void 0) {
        isAfter = false;
      }
      var itemProp = getCollection(this.tabs, collectionId);
      if (!itemProp) {
        return;
      }
      if (this.selectedTab === itemProp.tabIndex) {
        this.clearOverflowResize();
      }
      var ribbonItems = itemProp.collection.items.slice();
      var index = 0;
      if (targetId) {
        index = getIndex(ribbonItems, function (e) {
          return e.id === targetId;
        });
        index = index < 0 ? ribbonItems.length : isAfter ? index + 1 : index;
      } else {
        index = ribbonItems.length;
      }
      ribbonItems.splice(index, 0, item);
      itemProp.collection.setProperties({
        items: ribbonItems
      }, true);
      this.checkID([itemProp.collection.items[parseInt(index.toString(), 10)]], 'item', collectionId);
      var contentEle = this.tabObj.items[itemProp.tabIndex].content;
      var groupContainer = contentEle.querySelector('#' + itemProp.group.id + CONTAINER_ID);
      if (contentEle.innerHTML !== '') {
        var item_1 = itemProp.collection.items[parseInt(index.toString(), 10)];
        var element = this.createItems([item_1], itemProp.group.orientation, itemProp.group.id, itemProp.group.header, itemProp.group.enableGroupOverflow, itemProp.tabIndex, groupContainer)[0];
        if (itemProp.group.isCollapsed) {
          contentEle = this.ribbonDropDownModule.getOverflowDropDownPopup(itemProp, contentEle);
        }
        //insert the element in tab items property.
        var targetEle = targetId ? contentEle.querySelector('#' + targetId) : null;
        if (targetEle) {
          targetEle.closest('.' + RIBBON_ITEM).insertAdjacentElement(isAfter ? 'afterend' : 'beforebegin', element);
        } else {
          if (element) {
            contentEle.querySelector('#' + collectionId).append(element);
          }
        }
      }
      if (this.selectedTab === itemProp.tabIndex) {
        this.refreshLayout();
      }
    };
    /**
     * Removes ribbon item.
     *
     * @param {string} itemId - Gets the item ID.
     * @returns {void}
     */
    Ribbon.prototype.removeItem = function (itemId) {
      var itemProp = getItem(this.tabs, itemId);
      if (!itemProp) {
        return;
      }
      if (this.selectedTab === itemProp.tabIndex) {
        this.clearOverflowResize();
      }
      //Check whether the tab items are rendered
      var contentEle = this.tabObj.items[itemProp.tabIndex].content;
      if (contentEle.innerHTML !== '') {
        if (itemProp.group.isCollapsed) {
          contentEle = this.ribbonDropDownModule.getOverflowDropDownPopup(itemProp, contentEle);
        }
        var ele = contentEle.querySelector('#' + itemProp.item.id);
        if (ele) {
          this.destroyFunction(itemProp.item, ele);
          contentEle.querySelector('#' + itemId + CONTAINER_ID).remove();
        } else {
          var overflowDDB = void 0;
          var overflowtarget = void 0;
          var ofGroupContainer = void 0;
          if (itemProp.group.enableGroupOverflow) {
            var overflowDDBEle = contentEle.querySelector('#' + itemProp.group.id + GROUPOF_BUTTON_ID);
            if (overflowDDBEle) {
              overflowDDB = sf.base.getInstance(overflowDDBEle, sf.splitbuttons.DropDownButton);
              overflowtarget = overflowDDB.target;
            }
          } else {
            overflowDDB = this.overflowDDB;
            if (overflowDDB) {
              overflowtarget = this.overflowDDB.target;
              ofGroupContainer = overflowtarget.querySelector('#' + itemProp.group.id + CONTAINER_ID);
            }
          }
          if (overflowDDB) {
            var popupEle = overflowtarget.querySelector('#' + itemProp.item.id);
            this.destroyFunction(itemProp.item, popupEle);
            overflowtarget.querySelector('#' + itemProp.item.id + CONTAINER_ID).remove();
            if (itemProp.group.enableGroupOverflow && overflowDDB) {
              if (overflowtarget.childElementCount === 0) {
                this.removeOverflowButton(overflowDDB);
              }
            } else {
              if (ofGroupContainer.childElementCount === 1) {
                ofGroupContainer.remove();
              }
              var tabContainer = overflowtarget.querySelector('#' + this.tabs[itemProp.tabIndex].id + OVERFLOW_ID);
              if (tabContainer.childElementCount === 0) {
                tabContainer.remove();
              }
              if (overflowtarget.childElementCount === 0) {
                this.removeOverflowButton(this.overflowDDB);
                this.overflowDDB = null;
              }
            }
          }
        }
      }
      var ribbonCollection = itemProp.collection;
      var ribbonItems = ribbonCollection.items;
      ribbonItems.splice(itemProp.itemIndex, 1);
      ribbonCollection.setProperties({
        items: ribbonItems
      }, true);
      if (this.selectedTab === itemProp.tabIndex) {
        this.refreshLayout();
      }
    };
    /**
     * Enables ribbon item.
     *
     * @param {string} itemId - Gets the item ID.
     * @returns {void}
     */
    Ribbon.prototype.enableItem = function (itemId) {
      this.enableDisableItem(itemId, false);
    };
    /**
     * Disables ribbon item.
     *
     * @param {string} itemId - Gets the item ID.
     * @returns {void}
     */
    Ribbon.prototype.disableItem = function (itemId) {
      this.enableDisableItem(itemId, true);
    };
    Ribbon.prototype.enableDisableItem = function (itemId, isDisabled) {
      var itemProp = getItem(this.tabs, itemId);
      if (!itemProp) {
        return;
      }
      itemProp.item.setProperties({
        disabled: isDisabled
      }, true);
      var ele = getItemElement(this, itemProp, itemId);
      if (ele) {
        var moduleName = this.getItemModuleName(itemProp.item);
        if (moduleName !== 'template') {
          updateControlDisabled(ele, moduleName, isDisabled);
        } else {
          ele.classList[isDisabled ? 'add' : 'remove'](DISABLED_CSS);
          if (isDisabled) {
            ele.setAttribute('disabled', '');
          } else {
            ele.removeAttribute('disabled');
          }
        }
      }
    };
    Ribbon.prototype.unwireEvents = function () {
      sf.base.EventHandler.remove(window, 'resize', this.resizeHandler);
    };
    Ribbon.prototype.destroy = function () {
      this.destroyTabItems(this.tabs);
      this.removeExpandCollapse();
      this.collapseButton = undefined;
      if (this.scrollModule) {
        this.scrollModule.destroy();
      }
      if (this.ribbonTempEle) {
        sf.base.remove(this.ribbonTempEle);
      }
      _super.prototype.destroy.call(this);
      this.tabObj.destroy();
      this.unwireEvents();
    };
    /**
     * Called internally if any of the property value changed.
     *
     * @param  {RibbonModel} newProp - Specifies new properties
     * @param  {RibbonModel} oldProp - Specifies old properties
     * @returns {void}
     * @private
     */
    Ribbon.prototype.onPropertyChanged = function (newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case 'activeLayout':
            this.switchLayout();
            break;
          case 'cssClass':
            if (oldProp.cssClass) {
              sf.base.removeClass([this.element], oldProp.cssClass.split(SPACE));
            }
            if (newProp.cssClass) {
              sf.base.addClass([this.element], newProp.cssClass.split(SPACE));
            }
            break;
          case 'isMinimized':
            this.element.classList[this.isMinimized ? 'add' : 'remove'](RIBBON_MINIMIZE);
            break;
          case 'locale':
            this.updateCommonProperty({
              locale: this.locale
            });
            break;
          case 'enablePersistence':
            this.updateCommonProperty({
              enablePersistence: this.enablePersistence
            });
            break;
          case 'enableRtl':
            this.updateCommonProperty({
              enableRtl: newProp.enableRtl
            });
            break;
          case 'launcherIconCss':
            for (var i = 0; i < this.tabs.length; i++) {
              var tabContent = this.tabObj.items[parseInt(i.toString(), 10)].content;
              var tab = this.tabs[parseInt(i.toString(), 10)];
              if (tabContent.querySelector('.' + RIBBON_GROUP)) {
                for (var j = 0; j < tab.groups.length; j++) {
                  var group = tab.groups[parseInt(j.toString(), 10)];
                  if (group.showLauncherIcon) {
                    var className = RIBBON_LAUNCHER_ICON_ELE + ' ' + (this.launcherIconCss ? this.launcherIconCss : RIBBON_LAUNCHER_ICON);
                    if (group.isCollapsed) {
                      var element = tabContent.querySelector('.' + RIBBON_GROUP_OVERFLOW_DDB);
                      var dropdown = sf.base.getComponent(element, sf.splitbuttons.DropDownButton);
                      var launcherIconEle = dropdown.target.querySelector('#' + group.id + LAUNCHER_ID);
                      launcherIconEle.className = className;
                    } else {
                      var element = tabContent.querySelector('#' + group.id + LAUNCHER_ID);
                      element.className = className;
                    }
                  }
                }
              }
            }
            break;
          case 'selectedTab':
            this.tabObj.setProperties({
              selectedItem: newProp.selectedTab
            });
            break;
          case 'tabAnimation':
            this.tabObj.setProperties({
              animation: newProp.tabAnimation
            });
            break;
          case 'tabs':
            this.reRenderTabs();
            break;
          case 'width':
            this.element.style.width = sf.base.formatUnit(newProp.width);
            break;
          case 'fileMenu':
            this.ribbonFileMenuModule.updateFileMenu(this.fileMenu);
            break;
          case 'helpPaneTemplate':
            if (this.ribbonTempEle) {
              sf.base.remove(this.ribbonTempEle);
            }
            if (this.helpPaneTemplate) {
              this.createHelpPaneTemplate();
            }
            break;
        }
      }
    };
    var Ribbon_1;
    __decorate([sf.base.Property(exports.RibbonLayout.Classic)], Ribbon.prototype, "activeLayout", void 0);
    __decorate([sf.base.Property('')], Ribbon.prototype, "cssClass", void 0);
    __decorate([sf.base.Complex({}, FileMenuSettings)], Ribbon.prototype, "fileMenu", void 0);
    __decorate([sf.base.Property('')], Ribbon.prototype, "launcherIconCss", void 0);
    __decorate([sf.base.Property(false)], Ribbon.prototype, "isMinimized", void 0);
    __decorate([sf.base.Property('en-us')], Ribbon.prototype, "locale", void 0);
    __decorate([sf.base.Property(0)], Ribbon.prototype, "selectedTab", void 0);
    __decorate([sf.base.Complex({}, sf.navigations.TabAnimationSettings)], Ribbon.prototype, "tabAnimation", void 0);
    __decorate([sf.base.Collection([], RibbonTab)], Ribbon.prototype, "tabs", void 0);
    __decorate([sf.base.Property('100%')], Ribbon.prototype, "width", void 0);
    __decorate([sf.base.Property('')], Ribbon.prototype, "helpPaneTemplate", void 0);
    __decorate([sf.base.Event()], Ribbon.prototype, "tabSelecting", void 0);
    __decorate([sf.base.Event()], Ribbon.prototype, "tabSelected", void 0);
    __decorate([sf.base.Event()], Ribbon.prototype, "ribbonExpanding", void 0);
    __decorate([sf.base.Event()], Ribbon.prototype, "ribbonCollapsing", void 0);
    __decorate([sf.base.Event()], Ribbon.prototype, "launcherIconClick", void 0);
    Ribbon = Ribbon_1 = __decorate([sf.base.NotifyPropertyChanges], Ribbon);
    return Ribbon;
  }(sf.base.Component);

  /**
   * Ribbon modules
   */

  /**
   * Ribbon modules
   */

  // export all modules from current location
  // example: export * from './module'

  exports.Ribbon = Ribbon;
  exports.ITEM_VERTICAL_CENTER = ITEM_VERTICAL_CENTER;
  exports.EXPAND_COLLAPSE_ICON = EXPAND_COLLAPSE_ICON;
  exports.OVERFLOW_ICON = OVERFLOW_ICON;
  exports.VERTICAL_DDB = VERTICAL_DDB;
  exports.DISABLED_CSS = DISABLED_CSS;
  exports.RTL_CSS = RTL_CSS;
  exports.SPACE = SPACE;
  exports.HORIZONTAL_SCROLLBAR = HORIZONTAL_SCROLLBAR;
  exports.RIBBON_TAB = RIBBON_TAB;
  exports.RIBBON_TAB_ACTIVE = RIBBON_TAB_ACTIVE;
  exports.RIBBON_TAB_ITEM = RIBBON_TAB_ITEM;
  exports.RIBBON_COLLAPSE_BUTTON = RIBBON_COLLAPSE_BUTTON;
  exports.RIBBON_EXPAND_BUTTON = RIBBON_EXPAND_BUTTON;
  exports.RIBBON_COLLAPSIBLE = RIBBON_COLLAPSIBLE;
  exports.RIBBON_OVERALL_OF_BUTTON = RIBBON_OVERALL_OF_BUTTON;
  exports.RIBBON_GROUP_OF_BUTTON = RIBBON_GROUP_OF_BUTTON;
  exports.RIBBON_OVERFLOW_TARGET = RIBBON_OVERFLOW_TARGET;
  exports.RIBBON_OVERFLOW = RIBBON_OVERFLOW;
  exports.TAB_CONTENT = TAB_CONTENT;
  exports.RIBBON_MINIMIZE = RIBBON_MINIMIZE;
  exports.RIBBON_GROUP = RIBBON_GROUP;
  exports.RIBBON_GROUP_CONTAINER = RIBBON_GROUP_CONTAINER;
  exports.RIBBON_OF_TAB_CONTAINER = RIBBON_OF_TAB_CONTAINER;
  exports.RIBBON_OF_GROUP_CONTAINER = RIBBON_OF_GROUP_CONTAINER;
  exports.RIBBON_GROUP_CONTENT = RIBBON_GROUP_CONTENT;
  exports.RIBBON_GROUP_HEADER = RIBBON_GROUP_HEADER;
  exports.RIBBON_OVERFLOW_HEADER = RIBBON_OVERFLOW_HEADER;
  exports.RIBBON_GROUP_OVERFLOW = RIBBON_GROUP_OVERFLOW;
  exports.RIBBON_GROUP_OVERFLOW_DDB = RIBBON_GROUP_OVERFLOW_DDB;
  exports.RIBBON_LAUNCHER = RIBBON_LAUNCHER;
  exports.RIBBON_LAUNCHER_ICON_ELE = RIBBON_LAUNCHER_ICON_ELE;
  exports.RIBBON_LAUNCHER_ICON = RIBBON_LAUNCHER_ICON;
  exports.RIBBON_COLLECTION = RIBBON_COLLECTION;
  exports.RIBBON_ITEM = RIBBON_ITEM;
  exports.RIBBON_ROW = RIBBON_ROW;
  exports.RIBBON_COLUMN = RIBBON_COLUMN;
  exports.RIBBON_LARGE_ITEM = RIBBON_LARGE_ITEM;
  exports.RIBBON_MEDIUM_ITEM = RIBBON_MEDIUM_ITEM;
  exports.RIBBON_SMALL_ITEM = RIBBON_SMALL_ITEM;
  exports.RIBBON_CONTENT_HEIGHT = RIBBON_CONTENT_HEIGHT;
  exports.RIBBON_SIZE_CHECK = RIBBON_SIZE_CHECK;
  exports.DROPDOWNBUTTON = DROPDOWNBUTTON;
  exports.DROPDOWNBUTTON_HIDE = DROPDOWNBUTTON_HIDE;
  exports.RIBBON_RIGHT_TEMPLATE = RIBBON_RIGHT_TEMPLATE;
  exports.RIBBON_TOOLTIP = RIBBON_TOOLTIP;
  exports.RIBBON_TOOLTIP_TARGET = RIBBON_TOOLTIP_TARGET;
  exports.RIBBON_TOOLTIP_TITLE = RIBBON_TOOLTIP_TITLE;
  exports.RIBBON_TOOLTIP_CONTENT = RIBBON_TOOLTIP_CONTENT;
  exports.RIBBON_TOOLTIP_ICON = RIBBON_TOOLTIP_ICON;
  exports.RIBBON_TOOLTIP_CONTAINER = RIBBON_TOOLTIP_CONTAINER;
  exports.RIBBON_TEXT_CONTAINER = RIBBON_TEXT_CONTAINER;
  exports.RIBBON_SIMPLIFIED_MODE = RIBBON_SIMPLIFIED_MODE;
  exports.TAB_ID = TAB_ID;
  exports.GROUP_ID = GROUP_ID;
  exports.COLLECTION_ID = COLLECTION_ID;
  exports.ITEM_ID = ITEM_ID;
  exports.COLLAPSE_BUTTON_ID = COLLAPSE_BUTTON_ID;
  exports.OVRLOF_BUTTON_ID = OVRLOF_BUTTON_ID;
  exports.GROUPOF_BUTTON_ID = GROUPOF_BUTTON_ID;
  exports.HEADER_ID = HEADER_ID;
  exports.LAUNCHER_ID = LAUNCHER_ID;
  exports.CONTENT_ID = CONTENT_ID;
  exports.CONTAINER_ID = CONTAINER_ID;
  exports.OVERFLOW_ID = OVERFLOW_ID;
  exports.DROPDOWN_ID = DROPDOWN_ID;
  exports.RIBBON_FILE_MENU_ID = RIBBON_FILE_MENU_ID;
  exports.RIBBON_RIGHT_PANE_TEMPLATE_ID = RIBBON_RIGHT_PANE_TEMPLATE_ID;
  exports.RIBBON_FILE_MENU_WIDTH = RIBBON_FILE_MENU_WIDTH;
  exports.RIBBON_RIGHT_PANE_TEMPLATE_WIDTH = RIBBON_RIGHT_PANE_TEMPLATE_WIDTH;
  exports.getIndex = getIndex;
  exports.getItem = getItem;
  exports.getCollection = getCollection;
  exports.getGroup = getGroup;
  exports.destroyControl = destroyControl;
  exports.updateCommonProperty = updateCommonProperty;
  exports.updateControlDisabled = updateControlDisabled;
  exports.getItemElement = getItemElement;
  exports.isTooltipPresent = isTooltipPresent;
  exports.setToolTipContent = setToolTipContent;
  exports.RibbonTab = RibbonTab;
  exports.RibbonGroup = RibbonGroup;
  exports.RibbonCollection = RibbonCollection;
  exports.RibbonItem = RibbonItem;
  exports.RibbonButtonSettings = RibbonButtonSettings;
  exports.RibbonCheckBoxSettings = RibbonCheckBoxSettings;
  exports.RibbonColorPickerSettings = RibbonColorPickerSettings;
  exports.RibbonComboBoxSettings = RibbonComboBoxSettings;
  exports.RibbonDropDownSettings = RibbonDropDownSettings;
  exports.FileMenuSettings = FileMenuSettings;
  exports.RibbonTooltip = RibbonTooltip;
  exports.RibbonButton = RibbonButton;
  exports.RibbonCheckBox = RibbonCheckBox;
  exports.RibbonColorPicker = RibbonColorPicker;
  exports.RibbonComboBox = RibbonComboBox;
  exports.RibbonDropDown = RibbonDropDown;
  exports.RibbonFileMenu = RibbonFileMenu;
  return exports;
};
sf.ribbon = sf.ribbon({});

/***/ })

}]);(async()=>{await import(`${document.baseURI}_content/Syncfusion.Blazor/scripts/syncfusion-blazor-base.min.js?v=19.3.1`).then(()=>{})})();