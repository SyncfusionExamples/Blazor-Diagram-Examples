(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["sf-datepicker"],{

/***/ "./bundles/sf-datepicker.js":
/*!**********************************!*\
  !*** ./bundles/sf-datepicker.js ***!
  \**********************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_sf_datepicker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/sf-datepicker.js */ "./modules/sf-datepicker.js");
/* harmony import */ var _modules_sf_datepicker_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_sf_datepicker_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./modules/sf-datepicker.js":
/*!**********************************!*\
  !*** ./modules/sf-datepicker.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.DatePicker = function () {
  'use strict';

  var ARROWLEFT = 'ArrowLeft';
  var ARROWRIGHT = 'ArrowRight';
  var ARROWUP = 'ArrowUp';
  var ARROWDOWN = 'ArrowDown';
  var TAB = 'Tab';
  var SHIFTTAB = 'shiftTab';
  var END = 'End';
  var HOME = 'Home';
  var DELETE = 'Delete';
  var MaskedDateTime = /** @class */function () {
    function MaskedDateTime() {
      this.mask = '';
      this.hiddenMask = '';
      this.validCharacters = 'dMyhmHts';
      this.isDayPart = false;
      this.isMonthPart = false;
      this.isYearPart = false;
      this.isHourPart = false;
      this.isMinutePart = false;
      this.isSecondsPart = false;
      this.isMilliSecondsPart = false;
      this.monthCharacter = '';
      this.periodCharacter = '';
      this.isHiddenMask = false;
      this.isComplete = false;
      this.isNavigate = false;
      this.navigated = false;
      this.formatRegex = /E{3,4}|d{1,4}|M{1,4}|y{1,4}|H{1,2}|h{1,2}|m{1,2}|f{1,7}|FF|t{1,2}|s{1,2}|z{1,4}|'[^']*'|'[^']*'/g;
      this.isDeletion = false;
      this.isShortYear = false;
      this.isDeleteKey = false;
      this.isDateZero = false;
      this.isMonthZero = false;
      this.isYearZero = false;
      this.dayTypeCount = 0;
      this.monthTypeCount = 0;
      this.hourTypeCount = 0;
      this.minuteTypeCount = 0;
      this.secondTypeCount = 0;
    }
    //This method handles keyboard navigations.
    MaskedDateTime.prototype.keydownHandler = function (e) {
      switch (e.code) {
        case ARROWLEFT:
        case ARROWRIGHT:
        case ARROWUP:
        case ARROWDOWN:
        case HOME:
        case END:
        case DELETE:
          {
            if (e.code !== DELETE) {
              e.preventDefault();
            }
            if (!this.isPopupOpen) {
              this.maskKeydownHandler(e);
            }
          }
          break;
        case TAB:
        case SHIFTTAB:
          {
            this.maskKeydownHandler(e);
          }
          break;
        default:
          break;
      }
    };
    MaskedDateTime.prototype.clearHandler = function () {
      this.isDayPart = this.isMonthPart = this.isYearPart = this.isHourPart = this.isMinutePart = this.isSecondsPart = false;
      this.updateValue();
    };
    // Updates the current value.
    MaskedDateTime.prototype.updateValue = function () {
      this.monthCharacter = this.periodCharacter = '';
      var inputValue = this.dateformat.replace(this.formatRegex, this.formatCheck());
      this.isHiddenMask = true;
      this.hiddenMask = this.dateformat.replace(this.formatRegex, this.formatCheck());
      this.isHiddenMask = false;
      this.previousHiddenMask = this.hiddenMask;
      this.previousValue = inputValue;
    };
    // checks dates prefix 0 values
    MaskedDateTime.prototype.zeroCheck = function (isZero, isDayPart, resultValue) {
      var result = resultValue;
      if (isZero && !isDayPart) {
        result = '0';
      }
      return result;
    };
    // checks date and time values within the limit
    MaskedDateTime.prototype.roundOff = function (val, count) {
      var valueText = val.toString();
      var length = count - valueText.length;
      var result = '';
      for (var i = 0; i < length; i++) {
        result += '0';
      }
      return result + valueText;
    };
    // creates mask format values
    MaskedDateTime.prototype.formatCheck = function () {
      var proxy = this;
      function formatValueSpecifier(formattext) {
        var result;
        var daysAbbreviated = proxy.dayAbbreviatedName;
        var dayKeyAbbreviated = Object.keys(daysAbbreviated);
        var daysWide = proxy.dayName;
        var dayKeyWide = Object.keys(daysWide);
        var monthAbbreviated = proxy.monthAbbreviatedName;
        var monthWide = proxy.monthName;
        var periodString = proxy.dayPeriod;
        var periodkeys = Object.keys(periodString);
        var milliseconds;
        switch (formattext) {
          case 'd':
            result = proxy.isDayPart ? proxy.maskDateValue.getDate().toString() : proxy.maskPlaceholderDictionary['Day'].toString();
            result = proxy.zeroCheck(proxy.isDateZero, proxy.isDayPart, result);
            if (proxy.dayTypeCount == 2) {
              proxy.isNavigate = true;
              proxy.dayTypeCount = 0;
            }
            break;
          case 'dd':
            result = proxy.isDayPart ? proxy.roundOff(proxy.maskDateValue.getDate(), 2) : proxy.maskPlaceholderDictionary['Day'].toString();
            result = proxy.zeroCheck(proxy.isDateZero, proxy.isDayPart, result);
            if (proxy.dayTypeCount == 2) {
              proxy.isNavigate = true;
              proxy.dayTypeCount = 0;
            }
            break;
          case 'ddd':
            result = proxy.isDayPart && proxy.isMonthPart && proxy.isYearPart ? daysAbbreviated[dayKeyAbbreviated[proxy.maskDateValue.getDay()]].toString() : proxy.maskPlaceholderDictionary['DayOfWeek'].toString();
            break;
          case 'dddd':
            result = proxy.isDayPart && proxy.isMonthPart && proxy.isYearPart ? daysWide[dayKeyWide[proxy.maskDateValue.getDay()]].toString() : proxy.maskPlaceholderDictionary['DayOfWeek'].toString();
            break;
          case 'M':
            result = proxy.isMonthPart ? (proxy.maskDateValue.getMonth() + 1).toString() : proxy.maskPlaceholderDictionary['Month'].toString();
            result = proxy.zeroCheck(proxy.isMonthZero, proxy.isMonthPart, result);
            if (proxy.monthTypeCount == 2) {
              proxy.isNavigate = true;
              proxy.monthTypeCount = 0;
            }
            break;
          case 'MM':
            result = proxy.isMonthPart ? proxy.roundOff(proxy.maskDateValue.getMonth() + 1, 2) : proxy.maskPlaceholderDictionary['Month'].toString();
            result = proxy.zeroCheck(proxy.isMonthZero, proxy.isMonthPart, result);
            if (proxy.monthTypeCount == 2) {
              proxy.isNavigate = true;
              proxy.monthTypeCount = 0;
            }
            break;
          case 'MMM':
            result = proxy.isMonthPart ? monthAbbreviated[proxy.maskDateValue.getMonth()] : proxy.maskPlaceholderDictionary['Month'].toString();
            break;
          case 'MMMM':
            result = proxy.isMonthPart ? monthWide[proxy.maskDateValue.getMonth()] : proxy.maskPlaceholderDictionary['Month'].toString();
            break;
          case 'yy':
            result = proxy.isYearPart ? proxy.roundOff(proxy.maskDateValue.getFullYear() % 100, 2) : proxy.maskPlaceholderDictionary['Year'].toString();
            result = proxy.zeroCheck(proxy.isYearZero, proxy.isYearPart, result);
            if (proxy.isYearPart) {
              proxy.isNavigate = proxy.isShortYear = (proxy.maskDateValue.getFullYear() % 100).toString().length === 2;
            }
            break;
          case 'y':
          case 'yyyy':
            result = proxy.isYearPart ? proxy.roundOff(proxy.maskDateValue.getFullYear(), 4) : proxy.maskPlaceholderDictionary['Year'].toString();
            result = proxy.zeroCheck(proxy.isYearZero, proxy.isYearPart, result);
            break;
          case 'h':
            result = proxy.isHourPart ? (proxy.maskDateValue.getHours() % 12 || 12).toString() : proxy.maskPlaceholderDictionary['Hour'].toString();
            if (proxy.hourTypeCount == 2) {
              proxy.isNavigate = true;
              proxy.hourTypeCount = 0;
            }
            break;
          case 'hh':
            result = proxy.isHourPart ? proxy.roundOff(proxy.maskDateValue.getHours() % 12 || 12, 2) : proxy.maskPlaceholderDictionary['Hour'].toString();
            if (proxy.hourTypeCount == 2) {
              proxy.isNavigate = true;
              proxy.hourTypeCount = 0;
            }
            break;
          case 'H':
            result = proxy.isHourPart ? proxy.maskDateValue.getHours().toString() : proxy.maskPlaceholderDictionary['Hour'].toString();
            if (proxy.hourTypeCount == 2) {
              proxy.isNavigate = true;
              proxy.hourTypeCount = 0;
            }
            break;
          case 'HH':
            result = proxy.isHourPart ? proxy.roundOff(proxy.maskDateValue.getHours(), 2) : proxy.maskPlaceholderDictionary['Hour'].toString();
            if (proxy.hourTypeCount == 2) {
              proxy.isNavigate = true;
              proxy.hourTypeCount = 0;
            }
            break;
          case 'm':
            result = proxy.isMinutePart ? proxy.maskDateValue.getMinutes().toString() : proxy.maskPlaceholderDictionary['Minute'].toString();
            if (proxy.minuteTypeCount == 2) {
              proxy.isNavigate = true;
              proxy.minuteTypeCount = 0;
            }
            break;
          case 'mm':
            result = proxy.isMinutePart ? proxy.roundOff(proxy.maskDateValue.getMinutes(), 2) : proxy.maskPlaceholderDictionary['Minute'].toString();
            if (proxy.minuteTypeCount == 2) {
              proxy.isNavigate = true;
              proxy.minuteTypeCount = 0;
            }
            break;
          case 's':
            result = proxy.isSecondsPart ? proxy.maskDateValue.getSeconds().toString() : proxy.maskPlaceholderDictionary['Second'].toString();
            if (proxy.secondTypeCount == 2) {
              proxy.isNavigate = true;
              proxy.secondTypeCount = 0;
            }
            break;
          case 'ss':
            result = proxy.isSecondsPart ? proxy.roundOff(proxy.maskDateValue.getSeconds(), 2) : proxy.maskPlaceholderDictionary['Second'].toString();
            if (proxy.secondTypeCount == 2) {
              proxy.isNavigate = true;
              proxy.secondTypeCount = 0;
            }
            break;
          case 'f':
            result = Math.floor(proxy.maskDateValue.getMilliseconds() / 100).toString();
            break;
          case 'FF':
          case 'ff':
            milliseconds = proxy.maskDateValue.getMilliseconds();
            if (proxy.maskDateValue.getMilliseconds() > 99) {
              milliseconds = Math.floor(proxy.maskDateValue.getMilliseconds() / 10);
            }
            result = proxy.roundOff(milliseconds, 2);
            break;
          case 'fff':
            result = proxy.roundOff(proxy.maskDateValue.getMilliseconds(), 3);
            break;
          case 'ffff':
            result = proxy.roundOff(proxy.maskDateValue.getMilliseconds(), 4);
            break;
          case 'fffff':
            result = proxy.roundOff(proxy.maskDateValue.getMilliseconds(), 5);
            break;
          case 'ffffff':
            result = proxy.roundOff(proxy.maskDateValue.getMilliseconds(), 6);
            break;
          case 't':
          case 'tt':
            result = proxy.maskDateValue.getHours() < 12 ? periodString[periodkeys[0]] : periodString[periodkeys[1]];
            break;
          case 'z':
          case 'zz':
            result = proxy.offset.substring(0, 3);
            break;
          case 'zzz':
          case 'zzzz':
            result = proxy.offset;
            break;
        }
        if (formattext === 'ddd') {
          formattext = 'EEE';
        }
        if (formattext === 'dddd') {
          formattext = 'EEEE';
        }
        result = result !== undefined ? result : formattext.slice(1, formattext.length - 1);
        if (proxy.isHiddenMask) {
          var hiddenChar = '';
          for (var i = 0; i < result.length; i++) {
            hiddenChar += formattext[0];
          }
          return hiddenChar;
        } else {
          return result;
        }
      }
      return formatValueSpecifier;
    };
    // checks the difference in inputvalue
    MaskedDateTime.prototype.differenceCheck = function () {
      var inputElement = this.element;
      var start = inputElement.selectionStart;
      var inputValue = inputElement.value;
      var previousVal = this.previousValue.substring(0, start + this.previousValue.length - inputValue.length);
      var newVal = inputValue.substring(0, start);
      var newDateValue = !sf.base.isNullOrUndefined(newVal) && newVal.length > 0 ? new Date(+this.maskDateValue) : new Date(this.options.valueString);
      var maxDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth() + 1, 0).getDate();
      if (previousVal.indexOf(newVal) === 0 && (newVal.length === 0 || this.previousHiddenMask[newVal.length - 1] !== this.previousHiddenMask[newVal.length])) {
        for (var i = newVal.length; i < previousVal.length; i++) {
          if (this.previousHiddenMask[i] !== '' && this.validCharacters.indexOf(this.previousHiddenMask[i]) >= 0) {
            this.isDeletion = this.handleDeletion(this.previousHiddenMask[i], false);
          }
        }
        if (this.isDeletion) {
          return;
        }
      }
      switch (this.previousHiddenMask[start - 1]) {
        case 'd':
          var date = (this.isDayPart && newDateValue.getDate().toString().length < 2 && !this.isPersist() ? newDateValue.getDate() * 10 : 0) + parseInt(newVal[start - 1], 10);
          this.isDateZero = newVal[start - 1] == '0';
          this.isFocused = this.isFocused ? false : this.isFocused;
          this.navigated = this.navigated ? false : this.navigated;
          if (isNaN(date)) {
            return;
          }
          for (var i = 0; date > maxDate; i++) {
            date = parseInt(date.toString().slice(1), 10);
          }
          if (date >= 1) {
            newDateValue.setDate(date);
            this.isNavigate = date.toString().length === 2;
            this.previousDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth(), newDateValue.getDate());
            if (newDateValue.getMonth() !== this.maskDateValue.getMonth()) {
              return;
            }
            this.isDayPart = true;
            this.dayTypeCount = this.dayTypeCount + 1;
          } else {
            this.isDayPart = false;
            this.dayTypeCount = this.isDateZero ? this.dayTypeCount + 1 : this.dayTypeCount;
          }
          break;
        case 'M':
          var month = void 0;
          if (newDateValue.getMonth().toString().length < 2 && !this.isPersist()) {
            month = (this.isMonthPart ? (newDateValue.getMonth() + 1) * 10 : 0) + parseInt(newVal[start - 1], 10);
          } else {
            month = parseInt(newVal[start - 1], 10);
          }
          this.isFocused = this.isFocused ? false : this.isFocused;
          this.navigated = this.navigated ? false : this.navigated;
          this.isMonthZero = newVal[start - 1] == '0';
          if (!isNaN(month)) {
            while (month > 12) {
              var monthvalue = month;
              month = parseInt(month.toString().slice(1), 10);
              if (month === 0) {
                month = parseInt(monthvalue.toString().slice(0, 1), 10);
              }
            }
            if (month >= 1) {
              newDateValue.setMonth(month - 1);
              this.isNavigate = month.toString().length === 2;
              if (newDateValue.getMonth() !== month - 1) {
                newDateValue.setDate(1);
                newDateValue.setMonth(month - 1);
              }
              if (this.isDayPart) {
                var previousMaxDate = new Date(this.previousDate.getFullYear(), this.previousDate.getMonth() + 1, 0).getDate();
                var currentMaxDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth() + 1, 0).getDate();
                if (this.previousDate.getDate() == previousMaxDate && currentMaxDate <= previousMaxDate) {
                  newDateValue.setDate(currentMaxDate);
                }
              }
              this.previousDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth(), newDateValue.getDate());
              this.isMonthPart = true;
              this.monthTypeCount = this.monthTypeCount + 1;
            } else {
              newDateValue.setMonth(0);
              this.isMonthPart = false;
              this.monthTypeCount = this.isMonthZero ? this.monthTypeCount + 1 : this.monthTypeCount;
            }
          } else {
            var monthString = this.monthName;
            var monthValue = Object.keys(monthString);
            this.monthCharacter += newVal[start - 1].toLowerCase();
            while (this.monthCharacter.length > 0) {
              var i = 0;
              for (var _i = 0, monthValue_1 = monthValue; _i < monthValue_1.length; _i++) {
                var months = monthValue_1[_i];
                if (monthString[i].toLowerCase().indexOf(this.monthCharacter) === 0) {
                  newDateValue.setMonth(i);
                  this.isMonthPart = true;
                  this.maskDateValue = newDateValue;
                  return;
                }
                i++;
              }
              this.monthCharacter = this.monthCharacter.substring(1, this.monthCharacter.length);
            }
          }
          break;
        case 'y':
          var year = (this.isYearPart && newDateValue.getFullYear().toString().length < 4 && !this.isShortYear ? newDateValue.getFullYear() * 10 : 0) + parseInt(newVal[start - 1], 10);
          this.isShortYear = false;
          this.isYearZero = newVal[start - 1] == '0';
          if (isNaN(year)) {
            return;
          }
          while (year > 9999) {
            year = parseInt(year.toString().slice(1), 10);
          }
          if (year < 1) {
            this.isYearPart = false;
          } else {
            newDateValue.setFullYear(year);
            if (year.toString().length === 4) {
              this.isNavigate = true;
            }
            this.previousDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth(), newDateValue.getDate());
            this.isYearPart = true;
          }
          break;
        case 'h':
          this.hour = (this.isHourPart && (newDateValue.getHours() % 12 || 12).toString().length < 2 && !this.isPersist() ? (newDateValue.getHours() % 12 || 12) * 10 : 0) + parseInt(newVal[start - 1], 10);
          this.isFocused = this.isFocused ? false : this.isFocused;
          this.navigated = this.navigated ? false : this.navigated;
          if (isNaN(this.hour)) {
            return;
          }
          while (this.hour > 12) {
            this.hour = parseInt(this.hour.toString().slice(1), 10);
          }
          newDateValue.setHours(Math.floor(newDateValue.getHours() / 12) * 12 + this.hour % 12);
          this.isNavigate = this.hour.toString().length === 2;
          this.isHourPart = true;
          this.hourTypeCount = this.hourTypeCount + 1;
          break;
        case 'H':
          this.hour = (this.isHourPart && newDateValue.getHours().toString().length < 2 && !this.isPersist() ? newDateValue.getHours() * 10 : 0) + parseInt(newVal[start - 1], 10);
          this.isFocused = this.isFocused ? false : this.isFocused;
          this.navigated = this.navigated ? false : this.navigated;
          if (isNaN(this.hour)) {
            return;
          }
          for (var i = 0; this.hour > 23; i++) {
            this.hour = parseInt(this.hour.toString().slice(1), 10);
          }
          newDateValue.setHours(this.hour);
          this.isNavigate = this.hour.toString().length === 2;
          this.isHourPart = true;
          this.hourTypeCount = this.hourTypeCount + 1;
          break;
        case 'm':
          var minutes = (this.isMinutePart && newDateValue.getMinutes().toString().length < 2 && !this.isPersist() ? newDateValue.getMinutes() * 10 : 0) + parseInt(newVal[start - 1], 10);
          this.isFocused = this.isFocused ? false : this.isFocused;
          this.navigated = this.navigated ? false : this.navigated;
          if (isNaN(minutes)) {
            return;
          }
          for (var i = 0; minutes > 59; i++) {
            minutes = parseInt(minutes.toString().slice(1), 10);
          }
          newDateValue.setMinutes(minutes);
          this.isNavigate = minutes.toString().length === 2;
          this.isMinutePart = true;
          this.minuteTypeCount = this.minuteTypeCount + 1;
          break;
        case 's':
          var seconds = (this.isSecondsPart && newDateValue.getSeconds().toString().length < 2 && !this.isPersist() ? newDateValue.getSeconds() * 10 : 0) + parseInt(newVal[start - 1], 10);
          this.isFocused = this.isFocused ? false : this.isFocused;
          this.navigated = this.navigated ? false : this.navigated;
          if (isNaN(seconds)) {
            return;
          }
          for (var i = 0; seconds > 59; i++) {
            seconds = parseInt(seconds.toString().slice(1), 10);
          }
          newDateValue.setSeconds(seconds);
          this.isNavigate = seconds.toString().length === 2;
          this.isSecondsPart = true;
          this.secondTypeCount = this.secondTypeCount + 1;
          break;
        case 't':
          this.periodCharacter += newVal[start - 1].toLowerCase();
          var periodString = this.dayPeriod;
          var periodkeys = Object.keys(periodString);
          for (var i = 0; this.periodCharacter.length > 0; i++) {
            if (periodString[periodkeys[0]].toLowerCase().indexOf(this.periodCharacter) === 0 && newDateValue.getHours() >= 12 || periodString[periodkeys[1]].toLowerCase().indexOf(this.periodCharacter) === 0 && newDateValue.getHours() < 12) {
              newDateValue.setHours((newDateValue.getHours() + 12) % 24);
              this.maskDateValue = newDateValue;
            }
            this.periodCharacter = this.periodCharacter.substring(1, this.periodCharacter.length);
          }
          break;
        default:
          break;
      }
      this.maskDateValue = newDateValue;
    };
    //This method handles keyboard navigations
    MaskedDateTime.prototype.maskKeydownHandler = function (args) {
      var inputElement = this.element;
      this.dayTypeCount = this.monthTypeCount = this.hourTypeCount = this.minuteTypeCount = this.secondTypeCount = 0;
      if (args.key === DELETE) {
        this.isDeleteKey = true;
        return;
      }
      if (!args.altKey && !args.ctrlKey && (args.key === ARROWLEFT || args.key === ARROWRIGHT || args.key === SHIFTTAB || args.key === TAB || args.action === SHIFTTAB || args.key === END || args.key === HOME)) {
        var start = inputElement.selectionStart;
        var end = inputElement.selectionEnd;
        var length_1 = inputElement.value.length;
        if (start == 0 && end == length_1 && (args.key === TAB && !args.shiftKey || args.key === TAB && args.shiftKey)) {
          var index = args.key === TAB && args.shiftKey ? end : 0;
          inputElement.selectionStart = inputElement.selectionEnd = index;
        }
        if (args.key === END || args.key === HOME) {
          var range = args.key === END ? length_1 : 0;
          inputElement.selectionStart = inputElement.selectionEnd = range;
        }
        if ((args.key === ARROWLEFT || args.key === ARROWRIGHT) && start === 0 && end === length_1) {
          if (args.key === ARROWLEFT) {
            var val = inputElement.selectionEnd;
            for (var i = val, j = val - 1; i < this.hiddenMask.length || j >= 0; i++, j--) {
              if (i < this.hiddenMask.length && this.validCharacters.indexOf(this.hiddenMask[i]) !== -1) {
                this.setSelection(this.hiddenMask[i]);
                return;
              }
              if (j >= 0 && this.validCharacters.indexOf(this.hiddenMask[j]) !== -1) {
                this.setSelection(this.hiddenMask[j]);
                return;
              }
            }
          } else {
            this.validCharacterCheck();
          }
          return;
        }
        this.navigateSelection(args.key === ARROWLEFT || args.shiftKey && args.key === TAB || args.key === END ? true : false);
      }
      if (!args.altKey && !args.ctrlKey && (args.key === ARROWUP || args.key === ARROWDOWN)) {
        var start = inputElement.selectionStart;
        var formatText = '';
        if (this.validCharacters.indexOf(this.hiddenMask[start]) !== -1) {
          formatText = this.hiddenMask[start];
        }
        this.dateAlteration(args.key === ARROWDOWN ? true : false);
        var inputValue = this.dateformat.replace(this.formatRegex, this.formatCheck());
        this.isHiddenMask = true;
        this.hiddenMask = this.dateformat.replace(this.formatRegex, this.formatCheck());
        this.isHiddenMask = false;
        this.previousHiddenMask = this.hiddenMask;
        this.previousValue = inputValue;
        inputElement.value = inputValue;
        for (var i = 0; i < this.hiddenMask.length; i++) {
          if (formatText === this.hiddenMask[i]) {
            start = i;
            break;
          }
        }
        inputElement.selectionStart = start;
        this.validCharacterCheck();
      }
    };
    //this method handles date and time value increment and decrement 
    MaskedDateTime.prototype.dateAlteration = function (isDecrement) {
      var inputElement = this.element;
      var start = inputElement.selectionStart;
      var formatText = '';
      if (this.validCharacters.indexOf(this.hiddenMask[start]) !== -1) {
        formatText = this.hiddenMask[start];
      } else {
        return;
      }
      var newDateValue = new Date(this.maskDateValue.getFullYear(), this.maskDateValue.getMonth(), this.maskDateValue.getDate(), this.maskDateValue.getHours(), this.maskDateValue.getMinutes(), this.maskDateValue.getSeconds());
      this.previousDate = new Date(this.maskDateValue.getFullYear(), this.maskDateValue.getMonth(), this.maskDateValue.getDate(), this.maskDateValue.getHours(), this.maskDateValue.getMinutes(), this.maskDateValue.getSeconds());
      var incrementValue = isDecrement ? -1 : 1;
      switch (formatText) {
        case 'd':
          newDateValue.setDate(newDateValue.getDate() + incrementValue);
          break;
        case 'M':
          var newMonth = newDateValue.getMonth() + incrementValue;
          newDateValue.setDate(1);
          newDateValue.setMonth(newMonth);
          if (this.isDayPart) {
            var previousMaxDate = new Date(this.previousDate.getFullYear(), this.previousDate.getMonth() + 1, 0).getDate();
            var currentMaxDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth() + 1, 0).getDate();
            if (this.previousDate.getDate() == previousMaxDate && currentMaxDate <= previousMaxDate) {
              newDateValue.setDate(currentMaxDate);
            } else {
              newDateValue.setDate(this.previousDate.getDate());
            }
          } else {
            newDateValue.setDate(this.previousDate.getDate());
          }
          this.previousDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth(), newDateValue.getDate());
          break;
        case 'y':
          newDateValue.setFullYear(newDateValue.getFullYear() + incrementValue);
          break;
        case 'H':
        case 'h':
          newDateValue.setHours(newDateValue.getHours() + incrementValue);
          break;
        case 'm':
          newDateValue.setMinutes(newDateValue.getMinutes() + incrementValue);
          break;
        case 's':
          newDateValue.setSeconds(newDateValue.getSeconds() + incrementValue);
          break;
        case 't':
          newDateValue.setHours((newDateValue.getHours() + 12) % 24);
          break;
        default:
          break;
      }
      this.maskDateValue = newDateValue.getFullYear() > 0 ? newDateValue : this.maskDateValue;
      if (this.validCharacters.indexOf(this.hiddenMask[start]) !== -1) {
        this.handleDeletion(this.hiddenMask[start], true);
      }
    };
    // handle value delete operations
    MaskedDateTime.prototype.handleDeletion = function (format, isSegment) {
      switch (format) {
        case 'd':
          this.isDayPart = isSegment;
          break;
        case 'M':
          this.isMonthPart = isSegment;
          if (!isSegment) {
            this.maskDateValue.setMonth(0);
            this.monthCharacter = '';
          }
          break;
        case 'y':
          this.isYearPart = isSegment;
          break;
        case 'H':
        case 'h':
          this.isHourPart = isSegment;
          if (!isSegment) {
            this.periodCharacter = '';
          }
          break;
        case 'm':
          this.isMinutePart = isSegment;
          break;
        case 's':
          this.isSecondsPart = isSegment;
          break;
        default:
          return false;
      }
      return true;
    };
    //handle persist property
    MaskedDateTime.prototype.isPersist = function () {
      var isPersist = this.isFocused || this.navigated;
      return isPersist;
    };
    //updated the dynamic value changes
    MaskedDateTime.prototype.setDynamicValue = function () {
      this.maskDateValue = new Date(this.options.valueString);
      this.isDayPart = this.isMonthPart = this.isYearPart = this.isHourPart = this.isMinutePart = this.isSecondsPart = true;
      this.updateValue();
      if (!this.options.isBlurred) {
        this.validCharacterCheck();
      }
    };
    // handles the format selection 
    MaskedDateTime.prototype.validCharacterCheck = function () {
      var inputElement = this.element;
      var start = inputElement.selectionStart;
      if (this.componentName !== 'TimePicker') {
        if (start === this.hiddenMask.length && this.mask === inputElement.value) {
          start = 0;
        }
      }
      if (this.componentName === 'TimePicker') {
        if (start === this.hiddenMask.length) {
          inputElement.setSelectionRange(0, start);
          return;
        } else if (this.isPopupOpen) {
          inputElement.setSelectionRange(0, this.hiddenMask.length);
          return;
        }
      }
      for (var i = start, j = start - 1; i < this.hiddenMask.length || j >= 0; i++, j--) {
        if (i < this.hiddenMask.length && this.validCharacters.indexOf(this.hiddenMask[i]) !== -1) {
          this.setSelection(this.hiddenMask[i]);
          return;
        }
        if (j >= 0 && this.validCharacters.indexOf(this.hiddenMask[j]) !== -1) {
          this.setSelection(this.hiddenMask[j]);
          return;
        }
      }
    };
    //handles the format selection
    MaskedDateTime.prototype.setSelection = function (validChar) {
      var inputElement = this.element;
      var start = -1;
      var end = 0;
      for (var i = 0; i < this.hiddenMask.length; i++) {
        if (this.hiddenMask[i] === validChar) {
          end = i + 1;
          if (start === -1) {
            start = i;
          }
        }
      }
      if (start < 0) {
        start = 0;
      }
      inputElement.setSelectionRange(start, end);
    };
    // handle the input values with mask form
    MaskedDateTime.prototype.maskInputHandler = function () {
      var inputElement = this.element;
      var start = inputElement.selectionStart;
      var formatText = '';
      if (this.validCharacters.indexOf(this.hiddenMask[start]) !== -1) {
        formatText = this.hiddenMask[start];
      }
      var inputValue;
      this.differenceCheck();
      inputValue = this.dateformat.replace(this.formatRegex, this.formatCheck());
      this.isHiddenMask = true;
      this.hiddenMask = this.dateformat.replace(this.formatRegex, this.formatCheck());
      this.isDateZero = this.isMonthZero = this.isYearZero = false;
      this.isHiddenMask = false;
      this.previousHiddenMask = this.hiddenMask;
      this.previousValue = inputValue;
      inputElement.value = inputValue;
      for (var i = 0; i < this.hiddenMask.length; i++) {
        if (formatText === this.hiddenMask[i]) {
          start = i;
          break;
        }
      }
      inputElement.selectionStart = start;
      this.validCharacterCheck();
      if ((this.isNavigate || this.isDeletion) && !this.isDeleteKey) {
        var isbackward = this.isNavigate ? false : true;
        this.isNavigate = this.isDeletion = false;
        this.navigateSelection(isbackward);
      }
      if (this.isDeleteKey) {
        this.isDeletion = false;
      }
      this.isDeleteKey = false;
    };
    // handles the keyboard navigations
    MaskedDateTime.prototype.navigateSelection = function (isbackward) {
      var inputElement = this.element;
      var start = inputElement.selectionStart;
      var end = inputElement.selectionEnd;
      var formatIndex = isbackward ? start - 1 : end;
      this.navigated = true;
      while (formatIndex < this.hiddenMask.length && formatIndex >= 0) {
        if (this.validCharacters.indexOf(this.hiddenMask[formatIndex]) >= 0) {
          this.setSelection(this.hiddenMask[formatIndex]);
          break;
        }
        formatIndex = formatIndex + (isbackward ? -1 : 1);
      }
    };
    // creates mask forms and mask placeholders
    MaskedDateTime.prototype.createMask = function (options) {
      this.options = options;
      var inputElement = this.element;
      this.isDayPart = this.isMonthPart = this.isYearPart = this.isHourPart = this.isMinutePart = this.isSecondsPart = false;
      this.dateformat = this.options.format;
      var inputValue = this.dateformat.replace(this.formatRegex, this.formatCheck());
      this.isHiddenMask = true;
      this.hiddenMask = this.dateformat.replace(this.formatRegex, this.formatCheck());
      this.isHiddenMask = false;
      this.previousHiddenMask = this.hiddenMask;
      this.mask = this.previousValue = inputValue;
      if (this.options.value) {
        this.value = this.options.value;
        this.navigated = this.options.navigated;
        this.setDynamicValue();
      }
      inputValue = this.dateformat.replace(this.formatRegex, this.formatCheck());
      return {
        'currentMaskFormat': this.mask,
        'inputElementValue': inputValue
      };
    };
    MaskedDateTime.prototype.updateCurrentValue = function (currentValue) {
      var inputElement = this.element;
      inputElement.value = currentValue;
    };
    return MaskedDateTime;
  }();
  var ROOT = 'e-datepicker';
  var POPUPDIMENSION = '240px';
  var HALFPOSITION = 2;
  var POPUP_CONTAINER = 'e-popup-wrapper';
  var POPUP = 'e-popup';
  var OVERFLOW = 'e-date-overflow';
  var TIME_OVERFLOW = 'e-time-overflow';
  var CONENT = 'e-content';
  var FOOTER_CONTAINER = 'e-footer-container';
  var INPUT_HANDLER = 'InputKeyActionHandle';
  var TBODY = 'tbody';
  var TABLE = 'table';
  var HIDE_POPUP = 'HidePopup';
  var CLOSE_POPUP = 'ClosePopup';
  var SHOW_POPUP = 'ShowPopup';
  var MOUSE_TOUCH_EVENT = 'mousedown touchstart';
  var SELECTED = 'e-selected';
  var DAY = 'e-day';
  var TODAY = 'e-today';
  var BTN = 'e-btn';
  var OFFSETVALUE = 4;
  var OPENDURATION = 300;
  var INPUTCONTAINER = 'e-input-group';
  var ARIA_ACTIVE_DESCENDANT = "aria-activedescendant";
  var SfDatePicker = /** @class */function () {
    function SfDatePicker(dataId, containerElement, element, dotnetRef, options) {
      window.sfBlazor = window.sfBlazor;
      this.maskObj = new MaskedDateTime();
      this.componentName = "DatePicker";
      this.dataId = dataId;
      this.containerElement = containerElement;
      this.element = element;
      this.options = options;
      window.sfBlazor.setCompInstance(this);
      this.dotNetRef = dotnetRef;
      this.maskObj.element = this.element;
      this.enableMask = this.options.enableMask;
      if (this.enableMask) {
        this.maskObj.dateformat = this.options.format;
        this.maskObj.isRendered = this.options.isRendered;
        this.maskObj.componentName = this.componentName;
        this.maskObj.offset = this.options.offset;
        this.maskObj.floatLabelType = this.options.floatLabelType;
        this.maskObj.maskPlaceholderDictionary = this.options.maskPlaceholderDictionary;
        this.maskObj.dayAbbreviatedName = this.options.dayAbbreviatedName;
        this.maskObj.dayName = this.options.dayName;
        this.maskObj.dayPeriod = this.options.dayPeriod;
        this.maskObj.monthAbbreviatedName = this.options.monthAbbreviatedName;
        this.maskObj.monthName = this.options.monthName;
        this.maskObj.maskDateValue = !sf.base.isNullOrUndefined(this.options.value) ? new Date(this.options.value.toString()) : new Date();
        this.maskObj.maskDateValue.setMonth(0);
        this.maskObj.maskDateValue.setHours(0);
        this.maskObj.maskDateValue.setMinutes(0);
        this.maskObj.maskDateValue.setSeconds(0);
        this.maskObj.previousDate = new Date(this.maskObj.maskDateValue.getFullYear(), this.maskObj.maskDateValue.getMonth(), this.maskObj.maskDateValue.getDate(), this.maskObj.maskDateValue.getHours(), this.maskObj.maskDateValue.getMinutes(), this.maskObj.maskDateValue.getSeconds());
        this.removeEventListener();
        this.addEventListener();
      }
    }
    SfDatePicker.prototype.initialize = function () {
      this.defaultKeyConfigs = {
        altUpArrow: 'alt+uparrow',
        altDownArrow: 'alt+downarrow',
        escape: 'escape',
        enter: 'enter',
        controlUp: 'ctrl+38',
        controlDown: 'ctrl+40',
        moveDown: 'downarrow',
        moveUp: 'uparrow',
        moveLeft: 'leftarrow',
        moveRight: 'rightarrow',
        select: 'enter',
        home: 'home',
        end: 'end',
        pageUp: 'pageup',
        pageDown: 'pagedown',
        shiftPageUp: 'shift+pageup',
        shiftPageDown: 'shift+pagedown',
        controlHome: 'ctrl+home',
        controlEnd: 'ctrl+end',
        shiftTab: 'shift+tab',
        tab: 'tab'
      };
      this.defaultKeyConfigs = sf.base.extend(this.defaultKeyConfigs, this.options.keyConfigs);
      new sf.base.KeyboardEvents(this.element, {
        eventName: 'keydown',
        keyAction: this.inputKeyActionHandle.bind(this),
        keyConfigs: this.defaultKeyConfigs
      });
      this.index = this.options.showClearButton ? 2 : 1;
      sf.base.EventHandler.add(this.element, 'blur', this.inputBlurHandler, this);
    };
    SfDatePicker.prototype.bindInputEvent = function () {
      if (this.enableMask) {
        sf.base.EventHandler.add(this.element, 'input', this.inputHandler, this);
      } else {
        sf.base.EventHandler.remove(this.element, 'input', this.inputHandler);
      }
    };
    SfDatePicker.prototype.addEventListener = function () {
      sf.base.EventHandler.add(this.element, 'mouseup', this.mouseUpHandler, this);
      sf.base.EventHandler.add(this.element, 'keydown', this.keydownHandler, this);
      sf.base.EventHandler.add(this.element, 'focus', this.focusHandler, this);
      this.bindInputEvent();
    };
    SfDatePicker.prototype.removeEventListener = function () {
      sf.base.EventHandler.remove(this.element, 'mouseup', this.mouseUpHandler);
      sf.base.EventHandler.remove(this.element, 'keydown', this.keydownHandler);
      sf.base.EventHandler.remove(this.element, 'focus', this.focusHandler);
    };
    SfDatePicker.prototype.mouseUpHandler = function (e) {
      if (this.enableMask) {
        this.maskObj.element = this.element;
        e.preventDefault();
        this.maskObj.validCharacterCheck();
      }
    };
    SfDatePicker.prototype.focusHandler = function () {
      if (this.enableMask) {
        var inputElement = this.element;
        if (!this.options.value && this.options.placeholder && (this.maskObj.mask === inputElement.value || inputElement.value === '')) {
          if (this.options.floatLabelType === 'Auto' || this.options.floatLabelType === 'Never' || this.options.placeholder) {
            this.maskObj.updateCurrentValue(this.maskObj.mask);
            inputElement.selectionStart = 0;
            inputElement.selectionEnd = inputElement.value.length;
          }
        }
      }
    };
    SfDatePicker.prototype.inputHandler = function () {
      if (this.enableMask) {
        this.maskObj.element = this.element;
        this.maskObj.maskInputHandler();
      }
    };
    SfDatePicker.prototype.keydownHandler = function (e) {
      if (this.enableMask && !this.options.readonly) {
        this.maskObj.element = this.element;
        this.maskObj.keydownHandler(e);
      }
    };
    SfDatePicker.prototype.inputKeyActionHandle = function (e) {
      var keyEventsArgs;
      var inputElement = this.element;
      if (this.popupObj && this.popupObj.element.classList.contains(POPUP) && this.options.isDatePopup) {
        var focusedDate = this.tableBodyElement.querySelector('tr td.e-focused-date');
        var selectedDate = this.tableBodyElement.querySelector('tr td.' + SELECTED);
        this.tableBodyElement.focus();
        keyEventsArgs = {
          Action: e.action,
          Key: e.key,
          Events: e,
          SelectDate: selectedDate ? selectedDate.id : null,
          FocusedDate: focusedDate ? focusedDate.id : null,
          classList: selectedDate ? selectedDate.classList.toString() : focusedDate ? focusedDate.classList.toString() : 'e-cell',
          Id: focusedDate ? focusedDate.id : selectedDate ? selectedDate.id : null,
          TargetClassList: this.calendarElement.classList.toString()
        };
      } else {
        keyEventsArgs = {
          Action: e.action,
          Key: e.key,
          Events: e
        };
      }
      if (this.options.isDatePopup && this.maskObj.isPopupOpen && e.key == 'Enter') {
        inputElement.value = null;
      }
      if (!this.isDisposed) {
        this.dotNetRef.invokeMethodAsync(INPUT_HANDLER, keyEventsArgs, inputElement.value);
      }
      if (e.action !== 'select' && this.popupObj && document.body.contains(this.popupObj.element)) {
        e.preventDefault();
      }
    };
    SfDatePicker.prototype.inputBlurHandler = function (e) {
      if (this.isCalendar() && document.activeElement === this.element) {
        this.dotNetRef.invokeMethodAsync(HIDE_POPUP, e);
      }
    };
    // tslint:disable
    SfDatePicker.prototype.renderPopup = function (popupElement, popupHolderEle, openEventArgs, options) {
      this.options = options;
      this.maskObj.isPopupOpen = true;
      this.popupHolder = popupHolderEle;
      if (popupElement) {
        var oldPopupEle = document.getElementById(popupElement.id);
        if (oldPopupEle) {
          sf.base.remove(oldPopupEle);
        }
      }
      this.createCalendar(popupElement, options);
      if (sf.base.Browser.isDevice) {
        this.mobilePopupContainer = sf.base.createElement('div', {
          className: 'e-datepick-mob-popup-wrap'
        });
        document.body.appendChild(this.mobilePopupContainer);
      }
      var appendToElement = openEventArgs.appendTo === 'model' && this.mobilePopupContainer ? this.mobilePopupContainer : document.body;
      appendToElement.appendChild(this.popupContainer);
      this.popupObj.refreshPosition(this.element);
      if (!options.isDatePopup) {
        this.setScrollPosition();
      }
      var openAnimation = {
        name: 'FadeIn',
        duration: sf.base.Browser.isDevice ? 0 : OPENDURATION
      };
      if (this.options.zIndex === 1000) {
        this.popupObj.show(new sf.base.Animation(openAnimation), this.element);
      } else {
        this.popupObj.show(new sf.base.Animation(openAnimation), null);
      }
      this.setOverlayIndex(this.mobilePopupContainer, this.popupObj.element, this.modal, sf.base.Browser.isDevice);
      sf.base.EventHandler.add(document, MOUSE_TOUCH_EVENT, this.documentHandler, this);
      if (this.popupContainer.classList.contains('e-popup-expand')) {
        var modelHeader = this.popupContainer.querySelector(".e-model-header");
        var modelTodayButton = this.popupContainer.querySelector("button.e-today");
        modelTodayButton.classList.add("e-outline");
        modelHeader.insertBefore(modelTodayButton, modelHeader.firstChild);
      }
    };
    SfDatePicker.prototype.setOverlayIndex = function (popupContainer, popupElement, modal, isDevice) {
      if (isDevice && !sf.base.isNullOrUndefined(popupElement) && !sf.base.isNullOrUndefined(modal) && !sf.base.isNullOrUndefined(popupContainer)) {
        var index = parseInt(popupElement.style.zIndex, 10) ? parseInt(popupElement.style.zIndex, 10) : 1000;
        modal.style.zIndex = (index - 1).toString();
        popupContainer.style.zIndex = index.toString();
      }
    };
    SfDatePicker.prototype.closePopup = function (closeEventArgs, options) {
      this.options = options;
      this.maskObj.isPopupOpen = false;
      this.closeEventCallback(closeEventArgs);
    };
    SfDatePicker.prototype.CalendarScrollHandler = function (e) {
      var direction = 0;
      if (this.iconRight) {
        switch (e.swipeDirection) {
          case "Left":
            direction = 1;
            break;
          case "Right":
            direction = -1;
            break;
          default:
            break;
        }
      } else {
        switch (e.swipeDirection) {
          case "Up":
            direction = 1;
            break;
          case "Down":
            direction = -1;
            break;
          default:
            break;
        }
      }
      if (this.isTouchstart && direction !== 0) {
        this.dotNetRef.invokeMethodAsync("ScrollToNextSection", direction === 1);
        this.isTouchstart = false;
      }
    };
    SfDatePicker.prototype.TouchStartHandler = function (e) {
      this.isTouchstart = true;
    };
    SfDatePicker.prototype.createCalendar = function (popupElement, options) {
      var _this = this;
      this.popupContainer = popupElement;
      this.calendarElement = this.popupContainer.firstElementChild;
      this.tableBodyElement = sf.base.select(TBODY, this.calendarElement);
      var modelClassName = '' + ROOT + ' e-date-modal';
      var modelOverflow = OVERFLOW;
      if (!options.isDatePopup) {
        modelClassName = 'e-datetimepicker e-time-modal';
        modelOverflow = TIME_OVERFLOW;
      } else {
        this.calendarElement.querySelector(TABLE + ' ' + TBODY).className = '';
      }
      if (sf.base.Browser.isDevice) {
        this.modal = sf.base.createElement('div');
        this.modal.className = modelClassName;
        document.body.classList.add(modelOverflow);
        this.modal.style.display = 'block';
        document.body.appendChild(this.modal);
      }
      this.popupObj = new sf.popups.Popup(this.popupContainer, {
        width: options.isDatePopup ? 'auto' : this.setPopupWidth(this.options.width),
        relateTo: sf.base.Browser.isDevice ? document.body : this.containerElement,
        position: sf.base.Browser.isDevice ? {
          X: 'center',
          Y: 'center'
        } : {
          X: 'left',
          Y: 'bottom'
        },
        offsetY: OFFSETVALUE,
        targetType: 'container',
        enableRtl: options.enableRtl,
        zIndex: options.zIndex,
        collision: sf.base.Browser.isDevice ? {
          X: 'fit',
          Y: 'fit'
        } : {
          X: 'flip',
          Y: 'flip'
        },
        open: function open() {
          if (sf.base.Browser.isDevice) {
            _this.iconRight = parseInt(window.getComputedStyle(_this.calendarElement.querySelector('.e-header.e-month .e-prev')).marginRight, 10) > 16 ? true : false;
            _this.touchModule = new sf.base.Touch(_this.calendarElement.children[1].querySelector(".e-content.e-month"), {
              swipe: _this.CalendarScrollHandler.bind(_this)
            });
            sf.base.EventHandler.add(_this.calendarElement.children[1].querySelector(".e-content.e-month"), "touchstart", _this.TouchStartHandler, _this);
          }
          if (document.activeElement !== _this.element && options.isDatePopup) {
            _this.defaultKeyConfigs = sf.base.extend(_this.defaultKeyConfigs, options.keyConfigs);
            _this.calendarElement.children[1].firstElementChild.focus();
            new sf.base.KeyboardEvents(_this.calendarElement.children[1].firstElementChild, {
              eventName: 'keydown',
              keyAction: _this.CalendarKeyActionHandle.bind(_this),
              keyConfigs: _this.defaultKeyConfigs
            });
            new sf.base.KeyboardEvents(_this.containerElement.children[_this.index], {
              eventName: 'keydown',
              keyAction: _this.CalendarKeyActionHandle.bind(_this),
              keyConfigs: _this.defaultKeyConfigs
            });
          }
        },
        close: function close() {
          _this.popupHolder.appendChild(_this.popupContainer);
          if (_this.popupObj) {
            _this.popupObj.destroy();
          }
          if (!_this.isDisposed) {
            // tslint:disable
            _this.dotNetRef.invokeMethodAsync(CLOSE_POPUP)["catch"](function () {});
          }
          _this.popupObj = null;
        },
        targetExitViewport: function targetExitViewport() {
          if (!sf.base.Browser.isDevice && !_this.isDisposed) {
            _this.dotNetRef.invokeMethodAsync(HIDE_POPUP, null);
          }
        }
      });
      if (!options.isDatePopup) {
        if (this.popupContainer.classList.contains('e-popup-expand')) {
          this.popupObj.element.style.maxHeight = "100%";
          this.popupObj.element.style.width = "100%";
          this.popupObj.element.style.display = "flex";
        } else {
          this.popupObj.element.style.maxHeight = POPUPDIMENSION;
        }
      }
    };
    SfDatePicker.prototype.getPopupHeight = function () {
      var height = parseInt(POPUPDIMENSION, 10);
      var popupHeight = this.popupContainer.getBoundingClientRect().height;
      return popupHeight > height ? height : popupHeight;
    };
    SfDatePicker.prototype.setScrollPosition = function () {
      if ((this.popupContainer && this.popupContainer.querySelector('.e-navigation') || this.popupContainer.querySelector('.e-active')) && !this.options.isDatePopup) {
        var selectElement = this.popupContainer.querySelector('.e-navigation') || this.popupContainer.querySelector('.e-active');
        this.findScrollTop(selectElement);
      }
    };
    SfDatePicker.prototype.findScrollTop = function (element) {
      var listHeight = this.getPopupHeight();
      var nextEle = element.nextElementSibling;
      var height = nextEle ? nextEle.offsetTop : element.offsetTop;
      var liHeight = element.getBoundingClientRect().height;
      if (height + element.offsetTop > listHeight) {
        this.popupContainer.scrollTop = nextEle ? height - (listHeight / HALFPOSITION + liHeight / HALFPOSITION) : height;
      } else {
        this.popupContainer.scrollTop = 0;
      }
    };
    SfDatePicker.prototype.closeEventCallback = function (eventArgs) {
      var preventArgs = eventArgs;
      if (this.isCalendar() && !preventArgs.cancel && this.popupObj) {
        this.popupObj.hide();
      }
      if (sf.base.Browser.isDevice && this.modal) {
        this.modal.style.display = 'none';
        this.modal.outerHTML = '';
        this.modal = null;
      }
      if (sf.base.Browser.isDevice) {
        sf.base.removeClass([document.body], OVERFLOW);
        sf.base.removeClass([document.body], TIME_OVERFLOW);
        if (!sf.base.isNullOrUndefined(this.mobilePopupContainer)) {
          this.mobilePopupContainer.remove();
          this.mobilePopupContainer = null;
        }
      }
      sf.base.EventHandler.remove(document, MOUSE_TOUCH_EVENT, this.documentHandler);
      if (sf.base.Browser.isDevice && this.options.allowEdit && !this.options.readonly) {
        this.element.removeAttribute('readonly');
      }
    };
    SfDatePicker.prototype.documentHandler = function (e) {
      if (!sf.base.isNullOrUndefined(this.popupObj) && (this.containerElement.contains(e.target) || this.popupObj.element && this.popupObj.element.contains(e.target)) && e.type !== 'touchstart') {
        e.preventDefault();
      }
      var clearElement = this.containerElement.querySelector('.e-clear-icon');
      var selectedElement = this.tableBodyElement ? this.tableBodyElement.querySelector('.e-selected') : null;
      var dateValue = this.options.value ? this.options.value.toString() : null;
      var target = e.target;
      if (target == clearElement && selectedElement) {
        sf.base.removeClass([this.tableBodyElement.querySelector('.e-selected')], SELECTED);
      }
      if (!sf.base.closest(target, '.' + ROOT + '.' + POPUP_CONTAINER) && !sf.base.closest(target, '.' + 'e-datetimepicker' + '.' + POPUP_CONTAINER) && !(sf.base.closest(target, '.' + INPUTCONTAINER) === this.containerElement) && !target.classList.contains(DAY) && !this.isDisposed) {
        this.dotNetRef.invokeMethodAsync(HIDE_POPUP, e);
        this.element.focus();
      } else if (sf.base.closest(target, '.' + ROOT + '.' + POPUP_CONTAINER)) {
        if (target.classList.contains(DAY) && !sf.base.isNullOrUndefined(e.target.parentElement) && e.target.parentElement.classList.contains(SELECTED) && sf.base.closest(target, '.' + CONENT) && sf.base.closest(target, '.' + CONENT).classList.contains('e-' + this.options.depth.toLowerCase()) && !this.isDisposed) {
          this.dotNetRef.invokeMethodAsync(HIDE_POPUP, e);
        } else if (sf.base.closest(target, '.' + FOOTER_CONTAINER) && target.classList.contains(TODAY) && target.classList.contains(BTN) && +new Date(dateValue) === +this.generateTodayVal(new Date(dateValue)) && !this.isDisposed) {
          this.dotNetRef.invokeMethodAsync(HIDE_POPUP, e);
        }
      }
    };
    SfDatePicker.prototype.generateTodayVal = function (value) {
      var tempValue = new Date();
      if (value) {
        tempValue.setHours(value.getHours());
        tempValue.setMinutes(value.getMinutes());
        tempValue.setSeconds(value.getSeconds());
        tempValue.setMilliseconds(value.getMilliseconds());
      } else {
        tempValue = new Date(tempValue.getFullYear(), tempValue.getMonth(), tempValue.getDate(), 0, 0, 0, 0);
      }
      return tempValue;
    };
    SfDatePicker.prototype.isCalendar = function () {
      return this.popupContainer && this.popupContainer.classList.contains('' + POPUP_CONTAINER);
    };
    SfDatePicker.prototype.CalendarKeyActionHandle = function (e) {
      switch (e.action) {
        case this.defaultKeyConfigs.escape:
          if (this.isCalendar()) {
            this.dotNetRef.invokeMethodAsync(HIDE_POPUP, e);
          } else {
            this.element.blur();
          }
          break;
        case this.defaultKeyConfigs.enter:
          if (!this.isCalendar()) {
            this.dotNetRef.invokeMethodAsync(SHOW_POPUP, e);
          }
          break;
        case this.defaultKeyConfigs.tab:
          this.dotNetRef.invokeMethodAsync(HIDE_POPUP, e);
      }
    };
    SfDatePicker.prototype.setWidth = function (width) {
      if (typeof width === 'number') {
        width = sf.base.formatUnit(width);
      } else if (typeof width === 'string') {
        width = width.match(/px|%|em/) ? width : sf.base.formatUnit(width);
      } else {
        width = '100%';
      }
      return width;
    };
    SfDatePicker.prototype.setPopupWidth = function (width) {
      width = this.setWidth(width);
      if (width.indexOf('%') > -1) {
        var containerStyle = this.containerElement.getBoundingClientRect();
        var inputWidth = containerStyle.width * parseFloat(width) / 100;
        width = inputWidth.toString() + 'px';
      }
      return width;
    };
    SfDatePicker.prototype.updateAriaActiveDescendant = function (cellId) {
      this.element.setAttribute(ARIA_ACTIVE_DESCENDANT, cellId);
    };
    return SfDatePicker;
  }();
  // tslint:disable
  var DatePicker = {
    initialize: function initialize(dataId, containerElement, element, dotnetRef, options) {
      if (element && dataId) {
        var instance = new SfDatePicker(dataId, containerElement, element, dotnetRef, options);
        instance.initialize();
        if (!sf.base.isNullOrUndefined(sf.base.closest(element, "fieldset")) && sf.base.closest(element, "fieldset").disabled) {
          var enabled = options.enabled = false;
          instance.dotNetRef.invokeMethodAsync('UpdateFieldSetStatus', enabled);
        }
        if (options.enableMask) {
          return instance.maskObj.createMask(options);
        }
      }
      return {
        'currentMaskFormat': null,
        'inputElementValue': options.value
      };
    },
    createMask: function createMask(dataId, options) {
      if (dataId && options.enableMask) {
        var instance = window.sfBlazor.getCompInstance(dataId);
        return instance.maskObj.createMask(options);
      }
      return {
        'currentMaskFormat': null,
        'inputElementValue': options.value
      };
    },
    updateCurrentValue: function updateCurrentValue(dataId, currentValueAsString) {
      var instance = window.sfBlazor.getCompInstance(dataId);
      instance.maskObj.updateCurrentValue(currentValueAsString);
    },
    renderPopup: function renderPopup(dataId, popupElement, popupHolderEle, openEventArgs, options) {
      var instance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(instance) && popupElement && popupHolderEle) {
        instance.renderPopup(popupElement, popupHolderEle, openEventArgs, options);
      }
    },
    updateScrollPosition: function updateScrollPosition(dataId) {
      var instance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(instance)) {
        instance.setScrollPosition();
      }
    },
    // tslint:disable
    closePopup: function closePopup(dataId, closeEventArgs, options) {
      var instance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(instance) && closeEventArgs) {
        instance.closePopup(closeEventArgs, options);
      }
    },
    focusIn: function focusIn(dataId) {
      var instance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(instance)) {
        instance.element.focus();
      }
    },
    updateAriaActiveDescendant: function updateAriaActiveDescendant(dataId, cellId) {
      var instance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(instance)) {
        instance.updateAriaActiveDescendant(cellId);
      }
    },
    focusOut: function focusOut(dataId) {
      var instance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(instance)) {
        instance.element.blur();
      }
    },
    destroy: function destroy(dataId, popupElement, popupHolderEle, closeEventArgs, options) {
      var instance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(instance) && popupElement && popupElement instanceof HTMLElement && popupHolderEle) {
        instance.isDisposed = true;
        instance.closePopup(closeEventArgs, options);
      }
    }
  };
  return DatePicker;
}();

/***/ })

}]);(async()=>{await import(`${document.baseURI}_content/Syncfusion.Blazor/scripts/syncfusion-blazor-base.min.js?v=19.3.1`).then(()=>{sfBlazor.loadDependencies('sfdatepicker');})})();