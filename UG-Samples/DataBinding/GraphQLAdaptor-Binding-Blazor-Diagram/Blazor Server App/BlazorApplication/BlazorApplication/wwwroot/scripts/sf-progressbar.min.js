(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["sf-progressbar"],{

/***/ "./bundles/sf-progressbar.js":
/*!***********************************!*\
  !*** ./bundles/sf-progressbar.js ***!
  \***********************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_sf_progressbar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/sf-progressbar.js */ "./modules/sf-progressbar.js");
/* harmony import */ var _modules_sf_progressbar_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_sf_progressbar_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./modules/sf-progressbar.js":
/*!***********************************!*\
  !*** ./modules/sf-progressbar.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.Progressbar = function () {
  'use strict';

  /* eslint-disable max-len */
  var LINECAPRADIUS = 0.9;
  var SPACE = ' ';
  var SfProgressbar = /** @class */function () {
    function SfProgressbar(dataId, element, dotNetRef) {
      window.sfBlazor = window.sfBlazor;
      this.resizeTo = 0;
      this.element = element;
      this.dotNetRef = dotNetRef;
      // eslint-disable-next-line camelcase
      this.dataId = dataId;
      window.sfBlazor.setCompInstance(this);
    }
    SfProgressbar.prototype.wireEvents = function () {
      window.addEventListener(sf.base.Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize', this.resize.bind(this));
    };
    SfProgressbar.prototype.unWireEvents = function () {
      window.removeEventListener(sf.base.Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize', this.resize.bind(this));
      this.element = null;
      this.dotNetRef = null;
    };
    SfProgressbar.prototype.resize = function () {
      var _this = this;
      if (this.dotNetRef && !this.cancelResize || this.lineardata && this.lineardata.isActive || this.circularData && this.circularData.isActive) {
        if (this.resizeTo) {
          clearTimeout(this.resizeTo);
        }
        if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
          this.resizeTo = window.setTimeout(function () {
            _this.dotNetRef.invokeMethodAsync('TriggerResize');
          }, 500);
        }
      }
    };
    SfProgressbar.prototype.getPathArc = function (x, y, radius, startAngle, endAngle, enableRtl, pieView) {
      var start = this.degreeToLocation(x, y, radius, startAngle);
      var end = this.degreeToLocation(x, y, radius, endAngle);
      var largeArcFlag = '0';
      var sweepFlag = enableRtl ? '0' : '1';
      if (!enableRtl) {
        largeArcFlag = (endAngle >= startAngle ? endAngle : endAngle + 360) - startAngle <= 180 ? '0' : '1';
      } else {
        largeArcFlag = (startAngle >= endAngle ? startAngle : startAngle + 360) - endAngle <= 180 ? '0' : '1';
      }
      var d;
      if (pieView) {
        d = 'M ' + x + SPACE + y + ' L ' + start.x + SPACE + start.y + ' A ' + radius + SPACE + radius + SPACE + ' 0 ' + SPACE + largeArcFlag + SPACE + sweepFlag + SPACE + end.x + SPACE + end.y + SPACE + 'Z';
      } else {
        d = 'M' + start.x + SPACE + start.y + 'A' + radius + SPACE + radius + SPACE + '0' + SPACE + largeArcFlag + SPACE + sweepFlag + SPACE + end.x + SPACE + end.y;
      }
      return d;
    };
    SfProgressbar.prototype.degreeToLocation = function (centerX, centerY, radius, angleInDegrees) {
      var angleInRadians = (angleInDegrees - 90) * (Math.PI / 180);
      return {
        x: centerX + radius * Math.cos(angleInRadians),
        y: centerY + radius * Math.sin(angleInRadians)
      };
    };
    SfProgressbar.prototype.effect = function (currentTime, startValue, endValue, duration, enableRtl) {
      return (enableRtl ? endValue : -endValue) * Math.cos(currentTime / duration * (Math.PI / 2)) + (startValue + (enableRtl ? -endValue : endValue));
    };
    SfProgressbar.prototype.activeAnimate = function (time, start, end, enableRtl) {
      var activeTime = 1 - Math.pow(1 - time, 3);
      return start + (!enableRtl ? activeTime * end : -activeTime * end);
    };
    SfProgressbar.prototype.getPathLine = function (x, animateData) {
      var moveTo = animateData.enableRtl ? animateData.cornerRadius === 'Round' ? x + animateData.rectWidth - LINECAPRADIUS / 2 * animateData.thickness : x + animateData.rectWidth : animateData.cornerRadius === 'Round' ? x + LINECAPRADIUS / 2 * animateData.thickness : x;
      var lineTo = animateData.enableRtl ? animateData.cornerRadius === 'Round' && animateData.progressWidth ? moveTo - animateData.progressWidth + LINECAPRADIUS * animateData.thickness : moveTo - animateData.progressWidth : animateData.cornerRadius === 'Round' && animateData.progressWidth ? moveTo + animateData.progressWidth - LINECAPRADIUS * animateData.thickness : moveTo + animateData.progressWidth;
      return 'M' + moveTo + SPACE + (animateData.rectX + animateData.rectHeight / 2) + 'L' + lineTo + ' ' + (animateData.rectY + animateData.rectHeight / 2);
    };
    SfProgressbar.prototype.circularAnimation = function () {
      var _this = this;
      var animation = new sf.base.Animation({});
      var progressElement = document.getElementById(this.element.id + '_clippathcircle');
      var end = 0;
      if (progressElement && this.circularData) {
        progressElement.style.visibility = 'hidden';
        animation.animate(progressElement, {
          duration: this.circularData.duration,
          delay: this.circularData.delay,
          progress: function progress(args) {
            _this.cancelResize = true;
            if (args.timeStamp >= args.delay) {
              progressElement.style.visibility = 'visible';
              if (_this.circularData.isActive) {
                end = _this.activeAnimate(args.timeStamp / args.duration, _this.circularData.startPos, _this.circularData.endPos, _this.circularData.enableRtl);
                var activeElement = document.getElementById(_this.element.id + '_CircularActiveProgress');
                if (activeElement) {
                  activeElement.setAttribute('opacity', _this.effect(args.timeStamp, 0.5, 0.5, args.duration, true).toString());
                }
              } else {
                end = _this.effect(args.timeStamp, _this.circularData.startPos, _this.circularData.endPos, args.duration, _this.circularData.enableRtl);
              }
              progressElement.setAttribute('d', _this.getPathArc(_this.circularData.x, _this.circularData.y, _this.circularData.pathRadius, _this.circularData.start, end % 360, _this.circularData.enableRtl, true));
            }
          },
          end: function end() {
            _this.cancelResize = false;
            progressElement.setAttribute('d', _this.getPathArc(_this.circularData.x, _this.circularData.y, _this.circularData.pathRadius, _this.circularData.start, _this.circularData.progressEnd, _this.circularData.enableRtl, true));
            if (_this.circularData.isActive) {
              _this.circularAnimation();
            }
            _this.dotNetRef.invokeMethodAsync('TriggerAnimationComplete');
          }
        });
      }
    };
    SfProgressbar.prototype.circularBufferAnimation = function () {
      var _this = this;
      var animation = new sf.base.Animation({});
      var progressElement = document.getElementById(this.element.id + '_clippathBuffercircle');
      var end = 0;
      if (progressElement && this.circularBufferData) {
        progressElement.style.visibility = 'hidden';
        animation.animate(progressElement, {
          duration: this.circularBufferData.duration,
          delay: this.circularBufferData.delay,
          progress: function progress(args) {
            _this.cancelResize = true;
            if (args.timeStamp >= args.delay) {
              progressElement.style.visibility = 'visible';
              end = _this.effect(args.timeStamp, _this.circularBufferData.startPos, _this.circularBufferData.endPos, args.duration, _this.circularBufferData.enableRtl);
              progressElement.setAttribute('d', _this.getPathArc(_this.circularBufferData.x, _this.circularBufferData.y, _this.circularBufferData.pathRadius, _this.circularBufferData.start, end % 360, _this.circularBufferData.enableRtl, true));
            }
          },
          end: function end() {
            _this.cancelResize = false;
            progressElement.setAttribute('d', _this.getPathArc(_this.circularBufferData.x, _this.circularBufferData.y, _this.circularBufferData.pathRadius, _this.circularBufferData.start, _this.circularBufferData.progressEnd, _this.circularBufferData.enableRtl, true));
            _this.dotNetRef.invokeMethodAsync('TriggerAnimationComplete');
          }
        });
      }
    };
    SfProgressbar.prototype.circularIndeterminateAnimation = function (start, _end) {
      var _this = this;
      if (start === void 0) {
        start = 0;
      }
      if (_end === void 0) {
        _end = 0;
      }
      var progressElement = document.getElementById(this.element.id + '_clippathcircle');
      var animation = new sf.base.Animation({});
      if (progressElement && this.circularData) {
        animation.destroy();
        animation.animate(progressElement, {
          duration: this.circularData.duration,
          delay: 0,
          progress: function progress() {
            if (_this.circularData && _this.circularData.enable && _this.circularData.isIndeterminate) {
              progressElement.style.visibility = 'visible';
              start += _this.circularData.enableRtl ? -_this.circularData.segmentValue : _this.circularData.segmentValue;
              _end += _this.circularData.enableRtl ? -_this.circularData.segmentValue : _this.circularData.segmentValue;
              progressElement.setAttribute('d', _this.getPathArc(_this.circularData.x, _this.circularData.y, _this.circularData.pathRadius, start % 360, _end % 360, _this.circularData.enableRtl, !_this.circularData.enableProgressSegments));
            }
          },
          end: function end() {
            if (_this.circularData && _this.circularData.enable && _this.circularData.isIndeterminate) {
              _this.circularIndeterminateAnimation(start, _end);
            }
          }
        });
      }
    };
    SfProgressbar.prototype.annotationAnimation = function () {
      var _this = this;
      var animation = new sf.base.Animation({});
      var progressElement;
      var annotatElementChanged;
      var annotatElement = document.getElementById(this.element.id + 'Annotation0').children[0];
      if (annotatElement && annotatElement.children[0]) {
        if (annotatElement.children[0].tagName === 'SPAN') {
          annotatElementChanged = annotatElement.children[0];
        }
      }
      if (annotatElementChanged && this.annotationData) {
        if (this.annotationData.type === 'Linear') {
          progressElement = document.getElementById(this.element.id + '_clippathrect');
        } else {
          progressElement = document.getElementById(this.element.id + '_clippathcircle');
        }
        if (this.annotationData.isContent) {
          annotatElementChanged.innerHTML = this.annotationData.annotateValue + '%';
        } else if (progressElement) {
          animation.animate(progressElement, {
            duration: this.annotationData.duration,
            delay: this.annotationData.delay,
            progress: function progress(args) {
              _this.cancelResize = true;
              var effectValue = _this.effect(args.timeStamp, _this.annotationData.startPos, _this.annotationData.endPos, args.duration, false);
              var annotateValueChanged = parseInt(((Math.round(effectValue) - _this.annotationData.start) / _this.annotationData.totalAngle * 100).toString(), 10);
              annotatElementChanged.innerHTML = annotateValueChanged ? annotateValueChanged.toString() + '%' : '0%';
            },
            end: function end() {
              _this.cancelResize = false;
              annotatElementChanged.innerHTML = _this.annotationData.annotateValue + '%';
            }
          });
        }
      }
    };
    SfProgressbar.prototype.labelAnimation = function () {
      var _this = this;
      var labelElement;
      if (this.labelData) {
        labelElement = this.labelData.type === 'Linear' ? document.getElementById(this.element.id + '_linearLabel') : document.getElementById(this.element.id + '_circularLabel');
      }
      var animation = new sf.base.Animation({});
      var labelAnimation = new sf.base.Animation({});
      if (labelElement && this.labelData && !this.labelData.isStriped) {
        labelElement.style.visibility = 'hidden';
        animation.animate(labelElement, {
          duration: this.labelData.duration,
          delay: this.labelData.delay,
          progress: function progress(args) {
            _this.cancelResize = true;
            if (_this.labelData.type === 'Linear' && args.timeStamp >= args.delay && _this.labelData.labelText === '') {
              labelElement.style.visibility = 'visible';
              var effectValue = _this.effect(args.timeStamp, _this.labelData.progressPos, Math.round(_this.labelData.end - _this.labelData.progressPos), args.duration, false);
              var valueChanged = parseInt((effectValue / _this.labelData.width * 100).toString(), 10);
              labelElement.innerHTML = valueChanged.toString() + '%';
              if (_this.labelData.labelPos === 'Far' || _this.labelData.labelPos === 'Center') {
                var xPos = _this.effect(args.timeStamp, _this.labelData.startPos, _this.labelData.endPos - (_this.labelData.enableRtl ? 0 : _this.labelData.startPos), args.duration, _this.labelData.enableRtl);
                labelElement.setAttribute('x', xPos.toString());
              }
            } else if (_this.labelData.type === 'Circular' && _this.labelData.labelText === '') {
              labelElement.style.visibility = 'visible';
              var effectValue = _this.effect(args.timeStamp, _this.labelData.start, _this.labelData.end - _this.labelData.start, args.duration, false);
              var valueChanged = parseInt((effectValue / _this.labelData.totalAngle * 100).toString(), 10);
              labelElement.innerHTML = valueChanged.toString() + '%';
            }
          },
          end: function end() {
            _this.cancelResize = false;
            if (labelElement && _this.labelData.labelText === '') {
              labelElement.style.visibility = 'visible';
              labelElement.innerHTML = _this.labelData.text;
              labelElement.setAttribute('x', _this.labelData.x.toString());
            } else {
              labelAnimation.animate(labelElement, {
                progress: function progress(args) {
                  labelElement.style.visibility = 'visible';
                  var effectValue = _this.effect(args.timeStamp, 0, 1, args.duration, false);
                  labelElement.setAttribute('opacity', effectValue.toString());
                },
                end: function end() {
                  labelElement.setAttribute('opacity', '1');
                }
              });
            }
          }
        });
      }
    };
    SfProgressbar.prototype.stripeAnimation = function (pointValue) {
      var _this = this;
      if (pointValue === void 0) {
        pointValue = 0;
      }
      var animation = new sf.base.Animation({});
      var stripElement = document.getElementById(this.element.id + '_LinearStriped');
      if (stripElement && this.stripeData) {
        animation.animate(stripElement, {
          duration: this.stripeData.duration,
          delay: this.stripeData.delay,
          progress: function progress() {
            if (_this.stripeData.enable) {
              pointValue += _this.stripeData.enableRtl ? -_this.stripeData.durationValue : _this.stripeData.durationValue;
              stripElement.setAttribute('gradientTransform', 'translate(' + pointValue + ') rotate(-45)');
            }
          },
          end: function end() {
            if (_this.stripeData.enable) {
              _this.stripeAnimation(pointValue);
            }
          }
        });
      }
    };
    SfProgressbar.prototype.linearIndeterminateAnimation = function () {
      var _this = this;
      var animation = new sf.base.Animation({});
      var progressElement = document.getElementById(this.element.id + '_clippathrect');
      if (progressElement && this.lineardata) {
        progressElement.style.visibility = 'hidden';
        animation.animate(progressElement, {
          duration: this.lineardata.duration,
          delay: 0,
          progress: function progress(args) {
            progressElement.style.visibility = 'visible';
            if (_this.lineardata.enableRtl && _this.lineardata.enableRtl && _this.lineardata.enable && _this.lineardata.isIndeterminate) {
              _this.animationProgress(progressElement, args.timeStamp, _this.lineardata.x || _this.lineardata.rectX + _this.lineardata.progressWidth, _this.lineardata.end, args.duration, _this.lineardata.enableRtl);
            } else if (_this.lineardata.enable && _this.lineardata.isIndeterminate) {
              _this.animationProgress(progressElement, args.timeStamp, _this.lineardata.start, _this.lineardata.end, args.duration, _this.lineardata.enableRtl);
            }
          },
          end: function end() {
            if (_this.lineardata && _this.lineardata.enable && _this.lineardata.isIndeterminate) {
              if (_this.lineardata.enableRtl && !_this.lineardata.enableProgressSegments && !(_this.lineardata.cornerRadius === 'Round4px')) {
                progressElement.setAttribute('x', _this.lineardata.x.toString());
              } else if (!_this.lineardata.enableProgressSegments) {
                progressElement.setAttribute('x', _this.lineardata.start.toString());
              }
              _this.linearIndeterminateAnimation();
              _this.dotNetRef.invokeMethodAsync('TriggerAnimationComplete');
            }
          }
        });
      }
    };
    SfProgressbar.prototype.animationProgress = function (progressElement, timeStamp, lineardataStart, lineardataEnd, duration, enableRtl) {
      var xValue = this.effect(timeStamp, lineardataStart, lineardataEnd, duration, enableRtl);
      this.lineardata.enableProgressSegments ? progressElement.setAttribute('d', this.getPathLine(xValue, this.lineardata)) : progressElement.setAttribute('x', xValue.toString());
    };
    SfProgressbar.prototype.linearAnimation = function () {
      var _this = this;
      var animation = new sf.base.Animation({});
      var progressElement = document.getElementById(this.element.id + '_clippathrect');
      var widthValue = 0;
      if (progressElement && this.lineardata) {
        progressElement.style.visibility = 'hidden';
        animation.animate(progressElement, {
          duration: this.lineardata.duration,
          delay: this.lineardata.delay,
          progress: function progress(args) {
            _this.cancelResize = true;
            if (_this.lineardata.enableRtl && _this.lineardata.cornerRadius !== 'Round4px' && args.timeStamp >= args.delay) {
              progressElement.style.visibility = 'visible';
              if (_this.lineardata.isActive) {
                var activeElement = document.getElementById(_this.element.id + '_LinearActiveProgress');
                widthValue = _this.activeAnimate(args.timeStamp / args.duration, _this.lineardata.x, _this.lineardata.width, true);
                if (activeElement) {
                  activeElement.setAttribute('opacity', _this.effect(args.timeStamp, 0.5, 0.5, args.duration, true).toString());
                  progressElement.setAttribute('x', widthValue.toString());
                }
              } else {
                progressElement.setAttribute('x', _this.effect(args.timeStamp, _this.lineardata.start, _this.lineardata.end, args.duration, true).toString());
              }
            } else if (args.timeStamp >= args.delay) {
              progressElement.style.visibility = 'visible';
              if (_this.lineardata.isActive) {
                var activeElement = document.getElementById(_this.element.id + '_LinearActiveProgress');
                widthValue = _this.activeAnimate(args.timeStamp / args.duration, 0, _this.lineardata.width, _this.lineardata.enableRtl);
                if (activeElement) {
                  activeElement.setAttribute('opacity', _this.effect(args.timeStamp, 0.5, 0.5, args.duration, true).toString());
                  progressElement.setAttribute('width', widthValue.toString());
                }
              } else {
                progressElement.setAttribute('width', _this.effect(args.timeStamp, _this.lineardata.start, _this.lineardata.end, args.duration, false).toString());
              }
            }
          },
          end: function end() {
            _this.cancelResize = false;
            if (_this.lineardata && _this.lineardata.enable && _this.lineardata.enableRtl && _this.lineardata.cornerRadius !== 'Round4px') {
              if (_this.lineardata.isActive) {
                progressElement.setAttribute('x', _this.lineardata.x.toString());
                _this.linearAnimation();
              } else {
                progressElement.setAttribute('x', _this.lineardata.rtlX.toString());
              }
            } else if (_this.lineardata && _this.lineardata.enable) {
              progressElement.setAttribute('width', _this.lineardata.width.toString());
              if (_this.lineardata.isActive) {
                _this.linearAnimation();
              }
            }
            _this.dotNetRef.invokeMethodAsync('TriggerAnimationComplete');
          }
        });
      }
    };
    SfProgressbar.prototype.linearBufferAnimation = function () {
      var _this = this;
      var animation = new sf.base.Animation({});
      var progressElement = document.getElementById(this.element.id + '_clippathBufferrect');
      if (progressElement && this.linearBufferdata) {
        progressElement.style.visibility = 'hidden';
        animation.animate(progressElement, {
          duration: this.linearBufferdata.duration,
          delay: this.linearBufferdata.delay,
          progress: function progress(args) {
            _this.cancelResize = true;
            if (_this.linearBufferdata.enableRtl && _this.linearBufferdata.cornerRadius !== 'Round4px' && args.timeStamp >= args.delay) {
              if (args.timeStamp >= args.delay) {
                progressElement.style.visibility = 'visible';
                progressElement.setAttribute('x', _this.effect(args.timeStamp, _this.linearBufferdata.start, _this.linearBufferdata.end, args.duration, true).toString());
              }
            } else if (args.timeStamp >= args.delay) {
              progressElement.style.visibility = 'visible';
              progressElement.setAttribute('width', _this.effect(args.timeStamp, _this.linearBufferdata.start, _this.linearBufferdata.end, args.duration, false).toString());
            }
          },
          end: function end() {
            _this.cancelResize = false;
            progressElement.style.visibility = '';
            if (_this.lineardata && _this.linearBufferdata.enable && _this.linearBufferdata.enableRtl && _this.linearBufferdata.cornerRadius !== 'Round4px') {
              progressElement.setAttribute('x', _this.linearBufferdata.rtlX.toString());
            } else if (_this.linearBufferdata && _this.linearBufferdata.enable) {
              progressElement.setAttribute('width', _this.linearBufferdata.width.toString());
            }
            _this.dotNetRef.invokeMethodAsync('TriggerAnimationComplete');
          }
        });
      }
    };
    return SfProgressbar;
  }();
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var Progressbar = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    initialize: function initialize(dataId, element, height, width, dotNetRef) {
      var layout = new SfProgressbar(dataId, element, dotNetRef);
      layout.wireEvents();
      return this.getElementSize(element, height, width);
    },
    setSecondaryElementStyle: function setSecondaryElementStyle(element) {
      if (element) {
        var svgRect = document.getElementById(element.id + 'SVG').getBoundingClientRect();
        var secElement = document.getElementById(element.id + 'Secondary_Element');
        var elementRect = element.getBoundingClientRect();
        if (secElement && svgRect) {
          secElement.style.visibility = 'visible';
          secElement.style.left = Math.max(svgRect.left - elementRect.left, 0) + 'px';
          secElement.style.top = Math.max(svgRect.top - elementRect.top, 0) + 'px';
        }
      }
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getElementSize: function getElementSize(element, height, width) {
      var elementWidth;
      var elementHeight;
      if (element) {
        var display = element.style.display;
        element.style.display = 'block';
        element.style.height = height;
        element.style.width = width;
        var elementRect = element.getBoundingClientRect();
        elementWidth = elementRect.width;
        elementHeight = elementRect.height;
        element.style.width = '';
        element.style.height = '';
        element.style.display = display;
      }
      return {
        width: elementWidth,
        height: elementHeight
      };
    },
    doLinearBufferAnimation: function doLinearBufferAnimation(dataId, animateData) {
      var chartInstance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(chartInstance)) {
        chartInstance.linearBufferdata = animateData;
        chartInstance.linearBufferAnimation();
      }
    },
    doLinearAnimation: function doLinearAnimation(dataId, animateData) {
      var chartInstance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(chartInstance)) {
        chartInstance.lineardata = animateData;
        chartInstance.linearAnimation();
      }
    },
    doLinearIndeterminate: function doLinearIndeterminate(dataId, animateData) {
      var chartInstance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(chartInstance)) {
        chartInstance.lineardata = animateData;
        chartInstance.linearIndeterminateAnimation();
      }
    },
    doStripedAnimation: function doStripedAnimation(dataId, animateData) {
      var chartInstance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(chartInstance)) {
        chartInstance.stripeData = animateData;
        chartInstance.stripeAnimation();
      }
    },
    doCircularAnimation: function doCircularAnimation(dataId, circularData) {
      var chartInstance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(chartInstance)) {
        chartInstance.circularData = circularData;
        chartInstance.circularAnimation();
      }
    },
    doCircularBufferAnimation: function doCircularBufferAnimation(dataId, circularData) {
      var chartInstance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(chartInstance)) {
        chartInstance.circularBufferData = circularData;
        chartInstance.circularBufferAnimation();
      }
    },
    doCircularIndeterminate: function doCircularIndeterminate(dataId, circularData) {
      var chartInstance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(chartInstance)) {
        chartInstance.circularData = circularData;
        chartInstance.circularIndeterminateAnimation(circularData.start, circularData.end);
      }
    },
    doAnnotationAnimation: function doAnnotationAnimation(dataId, annotationData) {
      var chartInstance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(chartInstance)) {
        chartInstance.annotationData = annotationData;
        chartInstance.annotationAnimation();
      }
    },
    doLabelAnimation: function doLabelAnimation(dataId, labelData) {
      var chartInstance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(chartInstance)) {
        chartInstance.labelData = labelData;
        chartInstance.labelAnimation();
      }
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    update: function update(dataId, animateData, type, labelAnimateData, annotationData) {
      var chartInstance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(chartInstance)) {
        if (type === 'Linear') {
          var data = animateData;
          if (data.isStriped) {
            chartInstance.stripeData = data;
          } else {
            chartInstance.lineardata = data;
          }
        } else {
          chartInstance.circularData = animateData;
        }
        if (labelAnimateData) {
          chartInstance.labelData = animateData;
        }
        if (annotationData) {
          chartInstance.annotationData = animateData;
        }
      }
    },
    destroy: function destroy(dataId) {
      var chartInstance = window.sfBlazor.getCompInstance(dataId);
      if (dataId && chartInstance) {
        chartInstance.unWireEvents();
      }
    }
  };
  return Progressbar;
}();

/***/ })

}]);(async()=>{await import(`${document.baseURI}_content/Syncfusion.Blazor/scripts/syncfusion-blazor-base.min.js?v=19.3.1`).then(()=>{sfBlazor.loadDependencies('sfprogressbar');})})();